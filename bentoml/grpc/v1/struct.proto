syntax = "proto3";

package bentoml.grpc.v1;

import "google/protobuf/any.proto";

// cc_enable_arenas pre-allocate memory for given message to improve speed. (C++ only)
option cc_enable_arenas = true;
option cc_generic_services = true;
option go_package = "github.com/bentoml/grpc/v1";
option java_multiple_files = true;
option java_outer_classname = "StructProto";
option java_package = "com.bentoml.grpc.v1";
option objc_class_prefix = "STCT";

// Representing contents of a given rpc call.
message ContentsProto {
  // Serialized bytes contents.
  // The purpose of this representation is to
  // reduce serialization overhead during RPC call by avoiding serialization of
  // many repeated small items.
  repeated bytes bytes_contents = 1;

  // Type specific representations that make it easy to create protos in
  // all languages. The values hold the flattened representation of the inputs in row major order.
  //
  // Note that for quantized types, one should use ``bytes_contents`` and provide dtype at IO descriptor level.

  // DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we'll
  // have some pointless zero padding for each value here.
  repeated int32 half_contents = 10 [packed = true];

  // DT_FLOAT.
  repeated float float_contents = 2 [packed = true];

  // DT_DOUBLE.
  repeated double double_contents = 3 [packed = true];

  // DT_INT32, DT_INT16, DT_UINT16, DT_INT8, DT_UINT8.
  repeated int32 int_contents = 4 [packed = true];

  // DT_STRING
  repeated bytes string_contents = 5;

  // DT_COMPLEX64. scomplex_contents(2*i) and scomplex_contents(2*i+1) are real
  // and imaginary parts of i-th single precision complex.
  repeated float scomplex_contents = 6 [packed = true];

  // DT_INT64
  repeated int64 int64_contents = 7 [packed = true];

  // DT_BOOL
  repeated bool bool_contents = 8 [packed = true];

  // DT_COMPLEX128. dcomplex_contents(2*i) and dcomplex_contents(2*i+1) are real
  // and imaginary parts of i-th double precision complex.
  repeated double dcomplex_contents = 9 [packed = true];

  // DT_UINT32
  repeated uint32 uint32_contents = 11 [packed = true];

  // DT_UINT64
  repeated uint64 uint64_contents = 12 [packed = true];

  // This section represents a dynamic typed value representing various
  // data structures that are inspired by Python's data structures.

  // Represents a None value.
  repeated NoneValue none_contents = 50;

  // Represents a list of `ContentsProto`.
  repeated ListValue list_contents = 51;

  // Represents a tuple of `ContentsProto`.
  repeated TupleValue tuple_contents = 52;

  // Represents a dict `ContentsProto`.
  repeated DictValue dict_contents = 53;

  // Represents Python's namedtuple.
  repeated NamedTupleValue namedtuple_contents = 54;

  // To represent any type contents.
  repeated google.protobuf.Any any_contents = 55;

  // We want to reserve these for future uses.
  reserved 56 to 100;
}

// represents None type.
message NoneValue {}

// Represents a Python list.
message ListValue {
  repeated ContentsProto values = 1;
}

// Represents a Python tuple.
message TupleValue {
  repeated ContentsProto values = 1;
}

// Represents a Python dict with key<str> and value<ContentsProto>.
// This key is analogous with ContentsProto.string_contents.
// Note that map<> does not preserve order from given message.
message DictValue {
  map<string, ContentsProto> fields = 1;
}

// Represents a (key, value) pair.
message PairValue {
  string key = 1;
  ContentsProto value = 2;
}

// Represents a namedtuple.
// One key different from DictValue is that NamedTupleValue reserved
// the order of key value map, whereas map doesn't.
message NamedTupleValue {
  string name = 1;
  repeated PairValue values = 2;
}
