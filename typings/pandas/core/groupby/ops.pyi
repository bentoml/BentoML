from typing import Generic, Hashable, Iterator, Sequence
import numpy as np
from pandas._typing import ArrayLike, F, FrameOrSeries, Shape, final
from pandas.core.groupby import grouper
from pandas.core.indexes.api import Index
from pandas.core.series import Series
from pandas.util._decorators import cache_readonly

class WrappedCythonOp:
    cast_blocklist = ...
    def __init__(self, kind: str, how: str) -> None: ...
    _CYTHON_FUNCTIONS = ...
    _MASKED_CYTHON_FUNCTIONS = ...
    _cython_arity = ...
    def get_cython_func_and_vals(self, values: np.ndarray, is_numeric: bool): ...
    def get_out_dtype(self, dtype: np.dtype) -> np.dtype: ...
    def uses_mask(self) -> bool: ...
    @final
    def cython_operation(
        self,
        *,
        values: ArrayLike,
        axis: int,
        min_count: int = ...,
        comp_ids: np.ndarray,
        ngroups: int,
        **kwargs
    ) -> ArrayLike: ...

class BaseGrouper:
    axis: Index
    def __init__(
        self,
        axis: Index,
        groupings: Sequence[grouper.Grouping],
        sort: bool = ...,
        group_keys: bool = ...,
        mutated: bool = ...,
        indexer: np.ndarray | None = ...,
        dropna: bool = ...,
    ) -> None: ...
    @property
    def groupings(self) -> list[grouper.Grouping]: ...
    @property
    def shape(self) -> Shape: ...
    def __iter__(self): ...
    @property
    def nkeys(self) -> int: ...
    def get_iterator(
        self, data: FrameOrSeries, axis: int = ...
    ) -> Iterator[tuple[Hashable, FrameOrSeries]]: ...
    @final
    def apply(self, f: F, data: FrameOrSeries, axis: int = ...): ...
    @cache_readonly
    def indices(self): ...
    @property
    def codes(self) -> list[np.ndarray]: ...
    @property
    def levels(self) -> list[Index]: ...
    @property
    def names(self) -> list[Hashable]: ...
    @final
    def size(self) -> Series: ...
    @cache_readonly
    def groups(self) -> dict[Hashable, np.ndarray]: ...
    @final
    @cache_readonly
    def is_monotonic(self) -> bool: ...
    @cache_readonly
    def group_info(self): ...
    @final
    @cache_readonly
    def codes_info(self) -> np.ndarray: ...
    @final
    @cache_readonly
    def ngroups(self) -> int: ...
    @property
    def reconstructed_codes(self) -> list[np.ndarray]: ...
    @cache_readonly
    def result_arraylike(self) -> ArrayLike: ...
    @cache_readonly
    def result_index(self) -> Index: ...
    @final
    def get_group_levels(self) -> list[ArrayLike]: ...
    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = ...
    ) -> ArrayLike: ...

class BinGrouper(BaseGrouper):
    bins: np.ndarray
    binlabels: Index
    mutated: bool
    def __init__(self, bins, binlabels, mutated: bool = ..., indexer=...) -> None: ...
    @cache_readonly
    def groups(self): ...
    @property
    def nkeys(self) -> int: ...
    def get_iterator(self, data: FrameOrSeries, axis: int = ...): ...
    @cache_readonly
    def indices(self): ...
    @cache_readonly
    def group_info(self): ...
    @cache_readonly
    def reconstructed_codes(self) -> list[np.ndarray]: ...
    @cache_readonly
    def result_index(self): ...
    @property
    def levels(self) -> list[Index]: ...
    @property
    def names(self) -> list[Hashable]: ...
    @property
    def groupings(self) -> list[grouper.Grouping]: ...

class DataSplitter(Generic[FrameOrSeries]):
    def __init__(
        self, data: FrameOrSeries, labels, ngroups: int, axis: int = ...
    ) -> None: ...
    @cache_readonly
    def slabels(self) -> np.ndarray: ...
    def __iter__(self): ...
    @cache_readonly
    def sorted_data(self) -> FrameOrSeries: ...

class SeriesSplitter(DataSplitter): ...

class FrameSplitter(DataSplitter):
    def fast_apply(self, f: F, sdata: FrameOrSeries, names): ...

def get_splitter(
    data: FrameOrSeries, labels: np.ndarray, ngroups: int, axis: int = ...
) -> DataSplitter: ...
