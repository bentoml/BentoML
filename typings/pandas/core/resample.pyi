from typing import TYPE_CHECKING, Callable, Hashable, Literal
from pandas._typing import (
    FrameOrSeries,
    IndexLabel,
    T,
    TimedeltaConvertibleTypes,
    TimestampConvertibleTypes,
)
from pandas.core.base import PandasObject
from pandas.core.generic import NDFrame, _shared_docs
from pandas.core.groupby.groupby import BaseGroupBy, GroupBy, _pipe_template
from pandas.core.groupby.grouper import Grouper
from pandas.core.groupby.ops import BinGrouper
from pandas.util._decorators import (
    Appender,
    Substitution,
    deprecate_nonkeyword_arguments,
    doc,
)

if TYPE_CHECKING: ...
_shared_docs_kwargs: dict[str, str] = ...

class Resampler(BaseGroupBy, PandasObject):
    grouper: BinGrouper
    exclusions: frozenset[Hashable] = ...
    _attributes = ...
    def __init__(
        self,
        obj: FrameOrSeries,
        groupby: TimeGrouper,
        axis: int = ...,
        kind=...,
        *,
        selection=...,
        **kwargs
    ) -> None: ...
    def __str__(self) -> str: ...
    def __getattr__(self, attr: str): ...
    @property
    def obj(self) -> FrameOrSeries: ...
    @property
    def ax(self): ...
    @Substitution(
        klass="Resampler",
        examples="""
    >>> df = pd.DataFrame({'A': [1, 2, 3, 4]},
    ...                   index=pd.date_range('2012-08-02', periods=4))
    >>> df
                A
    2012-08-02  1
    2012-08-03  2
    2012-08-04  3
    2012-08-05  4
    To get the difference between each 2-day period's maximum and minimum
    value in one , you can do
    >>> df.resample('2D').pipe(lambda x: x.max() - x.min())
                A
    2012-08-02  1
    2012-08-04  1""",
    )
    @Appender(_pipe_template)
    def pipe(
        self, func: Callable[..., T] | tuple[Callable[..., T], str], *args, **kwargs
    ) -> T: ...
    _agg_see_also_doc = ...
    _agg_examples_doc = ...
    @doc(
        _shared_docs["aggregate"],
        see_also=_agg_see_also_doc,
        examples=_agg_examples_doc,
        klass="DataFrame",
        axis="",
    )
    def aggregate(self, func, *args, **kwargs): ...
    agg = ...
    apply = ...
    def transform(self, arg, *args, **kwargs): ...
    def pad(self, limit=...): ...
    ffill = ...
    def nearest(self, limit=...): ...
    def backfill(self, limit=...): ...
    bfill = ...
    def fillna(self, method, limit=...): ...
    @deprecate_nonkeyword_arguments(version=None, allowed_args=["self", "method"])
    @doc(NDFrame.interpolate, **_shared_docs_kwargs)
    def interpolate(
        self,
        method=...,
        axis=...,
        limit=...,
        inplace=...,
        limit_direction=...,
        limit_area=...,
        downcast=...,
        **kwargs
    ): ...
    def asfreq(self, fill_value=...): ...
    def std(self, ddof=..., *args, **kwargs): ...
    def var(self, ddof=..., *args, **kwargs): ...
    @doc(GroupBy.size)
    def size(self): ...
    @doc(GroupBy.count)
    def count(self): ...
    def quantile(self, q=..., **kwargs): ...

class _GroupByMixin(PandasObject):
    _attributes: list[str]
    _selection: IndexLabel | None = ...
    def __init__(self, obj, parent=..., groupby=..., **kwargs) -> None: ...
    _upsample = ...
    _downsample = ...
    _groupby_and_aggregate = ...

class DatetimeIndexResampler(Resampler): ...
class DatetimeIndexResamplerGroupby(_GroupByMixin, DatetimeIndexResampler): ...
class PeriodIndexResampler(DatetimeIndexResampler): ...
class PeriodIndexResamplerGroupby(_GroupByMixin, PeriodIndexResampler): ...
class TimedeltaIndexResampler(DatetimeIndexResampler): ...
class TimedeltaIndexResamplerGroupby(_GroupByMixin, TimedeltaIndexResampler): ...

def get_resampler(obj, kind=..., **kwds): ...
def get_resampler_for_grouping(
    groupby, rule, how=..., fill_method=..., limit=..., kind=..., on=..., **kwargs
): ...

class TimeGrouper(Grouper):
    _attributes = ...
    def __init__(
        self,
        freq=...,
        closed: Literal["left", "right"] | None = ...,
        label: str | None = ...,
        how=...,
        axis=...,
        fill_method=...,
        limit=...,
        loffset=...,
        kind: str | None = ...,
        convention: str | None = ...,
        base: int | None = ...,
        origin: str | TimestampConvertibleTypes = ...,
        offset: TimedeltaConvertibleTypes | None = ...,
        **kwargs
    ) -> None: ...

def asfreq(
    obj: FrameOrSeries, freq, method=..., how=..., normalize: bool = ..., fill_value=...
) -> FrameOrSeries: ...
