"""
This type stub file was generated by pyright.
"""

from typing import (TYPE_CHECKING, Any, ClassVar, Dict, Iterator, Mapping,
                    Optional, Tuple, Type, Union)

from .main import BaseModel

_generic_types_cache: Dict[
    Tuple[Type[Any], Union[Any, Tuple[Any, ...]]], Type[BaseModel]
] = ...
GenericModelT = ...
TypeVarType = Any

class GenericModel(BaseModel):
    __slots__ = ...
    __concrete__: ClassVar[bool] = ...
    if TYPE_CHECKING:
        __parameters__: ClassVar[Tuple[TypeVarType, ...]]
        ...
    def __class_getitem__(
        cls: Type[GenericModelT], params: Union[Type[Any], Tuple[Type[Any], ...]]
    ) -> Type[Any]:
        """Instantiates a new class from a generic class `cls` and type variables `params`.

        :param params: Tuple of types the class . Given a generic class
            `Model` with 2 type variables and a concrete model `Model[str, int]`,
            the value `(str, int)` would be passed to `params`.
        :return: New model class inheriting from `cls` with instantiated
            types described by `params`. If no parameters are given, `cls` is
            returned as is.

        """
        ...
    @classmethod
    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...]) -> str:
        """Compute class name for child classes.

        :param params: Tuple of types the class . Given a generic class
            `Model` with 2 type variables and a concrete model `Model[str, int]`,
            the value `(str, int)` would be passed to `params`.
        :return: String representing a the new class where `params` are
            passed to `cls` as type variables.

        This method can be overridden to achieve a custom naming scheme for GenericModels.
        """
        ...

def replace_types(type_: Any, type_map: Mapping[Any, Any]) -> Any:
    """Return type with all occurances of `type_map` keys recursively replaced with their values.

    :param type_: Any type, class or generic alias
    :param type_map: Mapping from `TypeVar` instance to concrete types.
    :return: New type representing the basic structure of `type_` with all
        `typevar_map` keys recursively replaced.

    >>> replace_types(Tuple[str, Union[List[str], float]], {str: int})
    Tuple[int, Union[List[int], float]]

    """
    ...

def check_parameters_count(
    cls: Type[GenericModel], parameters: Tuple[Any, ...]
) -> None: ...

DictValues: Type[Any] = ...

def iter_contained_typevars(v: Any) -> Iterator[TypeVarType]:
    """Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found."""
    ...

def get_caller_frame_info() -> Tuple[Optional[str], bool]:
    """
    Used inside a function to check whether it was called globally

    Will only work against non-compiled code, therefore used only in pydantic.generics

    :returns Tuple[module_name, called_globally]
    """
    ...
