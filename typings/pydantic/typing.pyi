"""
This type stub file was generated by pyright.
"""

import sys
from typing import TYPE_CHECKING, AbstractSet, Any
from typing import Callable as TypingCallable
from typing import (
    Dict,
    ForwardRef,
    Generator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    Union,
)

from .fields import ModelField

if sys.version_info < (3, 7): ...
else: ...
if sys.version_info < (3, 7): ...
else:
    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any: ...

if sys.version_info < (3, 9):
    get_all_type_hints = ...
else: ...
if sys.version_info < (3, 7): ...
else:
    AnyCallable = TypingCallable[..., Any]
    NoArgAnyCallable = TypingCallable[[], Any]
AnnotatedTypeNames = ...
if sys.version_info < (3, 8): ...
else:
    def get_origin(tp: Type[Any]) -> Type[Any]:
        """
        We can't directly use `typing.get_origin` since we need a fallback to support
        custom generic classes like `ConstrainedList`
        It should be useless once https://github.com/cython/cython/issues/3537 is
        solved and https://github.com/samuelcolvin/pydantic/pull/1753 is merged.
        """
        ...

if sys.version_info < (3, 7): ...
else:
    def get_args(tp: Type[Any]) -> Tuple[Any, ...]:
        """Get type arguments with all substitutions performed.

        For unions, basic simplifications used by Union constructor are performed.
        Examples::
            get_args(Dict[str, int]) == (str, int)
            get_args(int) == ()
            get_args(Union[int, Union[T, int], str][int]) == (int, str)
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
            get_args(Callable[[], T][int]) == ([], int)
        """
        ...

if TYPE_CHECKING:
    TupleGenerator = Generator[Tuple[str, Any], None, None]
    DictStrAny = Dict[str, Any]
    DictAny = Dict[Any, Any]
    SetStr = Set[str]
    ListStr = List[str]
    IntStr = Union[int, str]
    AbstractSetIntStr = AbstractSet[IntStr]
    DictIntStrAny = Dict[IntStr, Any]
    MappingIntStrAny = Mapping[IntStr, Any]
    CallableGenerator = Generator[AnyCallable, None, None]
    ReprArgs = Sequence[Tuple[Optional[str], Any]]
__all__ = (
    "ForwardRef",
    "Callable",
    "AnyCallable",
    "NoArgAnyCallable",
    "NoneType",
    "NONE_TYPES",
    "display_as_type",
    "resolve_annotations",
    "is_callable_type",
    "is_literal_type",
    "all_literal_values",
    "is_namedtuple",
    "is_typeddict",
    "is_new_type",
    "new_type_supertype",
    "is_classvar",
    "update_field_forward_refs",
    "TupleGenerator",
    "DictStrAny",
    "DictAny",
    "SetStr",
    "ListStr",
    "IntStr",
    "AbstractSetIntStr",
    "DictIntStrAny",
    "CallableGenerator",
    "ReprArgs",
    "CallableGenerator",
    "GenericAlias",
    "get_args",
    "get_origin",
    "typing_base",
    "get_all_type_hints",
)
NoneType = None.__class__
NONE_TYPES: Set[Any] = ...

def display_as_type(v: Type[Any]) -> str: ...
def resolve_annotations(
    raw_annotations: Dict[str, Type[Any]], module_name: Optional[str]
) -> Dict[str, Type[Any]]:
    """
    Partially taken from typing.get_type_hints.

    Resolve string or ForwardRef annotations into type objects if possible.
    """
    ...

def is_callable_type(type_: Type[Any]) -> bool: ...

if sys.version_info >= (3, 7):
    def is_literal_type(type_: Type[Any]) -> bool: ...
    def literal_values(type_: Type[Any]) -> Tuple[Any, ...]: ...

else: ...

def all_literal_values(type_: Type[Any]) -> Tuple[Any, ...]:
    """
    This method is used to retrieve all Literal values as
    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
    e.g. `Literal[Literal[Literal[1, 2, 3], "foo"], 5, None]`
    """
    ...

def is_namedtuple(type_: Type[Any]) -> bool:
    """
    Check if a given class is a named tuple.
    It can be either a `typing.NamedTuple` or `collections.namedtuple`
    """
    ...

def is_typeddict(type_: Type[Any]) -> bool:
    """
    Check if a given class is a typed dict (from `typing` or `typing_extensions`)
    In 3.10, there will be a public method (https://docs.python.org/3.10/library/typing.html#typing.is_typeddict)
    """
    ...

test_type = ...

def is_new_type(type_: Type[Any]) -> bool:
    """
    Check whether type_ was created using typing.NewType
    """
    ...

def new_type_supertype(type_: Type[Any]) -> Type[Any]: ...
def is_classvar(ann_type: Type[Any]) -> bool: ...
def update_field_forward_refs(field: ModelField, globalns: Any, localns: Any) -> None:
    """
    Try to update ForwardRefs on fields based on this ModelField, globalns and localns.
    """
    ...

def get_class(type_: Type[Any]) -> Union[None, bool, Type[Any]]:
    """
    Tries to get the class of a Type[T] annotation. Returns True if Type is used
    without brackets. Otherwise returns None.
    """
    ...
