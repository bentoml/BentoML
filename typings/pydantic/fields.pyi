"""
This type stub file was generated by pyright.
"""

from typing import TYPE_CHECKING, Any, Dict, Optional, Set, Tuple, Type, Union

from .class_validators import Validator
from .error_wrappers import ErrorList
from .main import BaseConfig
from .types import ModelOrDc
from .typing import NoArgAnyCallable, ReprArgs
from .utils import Representation

Required: Any = ...
T = ...

class UndefinedType:
    def __repr__(self) -> str: ...
    def __copy__(self: T) -> T: ...
    def __reduce__(self) -> str: ...
    def __deepcopy__(self: T, _: Any) -> T: ...

Undefined = ...
if TYPE_CHECKING:
    ValidateReturn = Tuple[Optional[Any], Optional[ErrorList]]
    LocStr = Union[Tuple[Union[int, str], ...], str]
    BoolUndefined = Union[bool, UndefinedType]

class FieldInfo(Representation):
    """
    Captures extra information about a field.
    """

    __slots__ = ...
    __field_constraints__ = ...
    def __init__(self, default: Any = ..., **kwargs: Any) -> None: ...
    def __repr_args__(self) -> ReprArgs: ...
    def get_constraints(self) -> Set[str]:
        """
        Gets the constraints set on the field by comparing the constraint value with its default value

        :return: the constraints set on field_info
        """
        ...
    def update_from_config(self, from_config: Dict[str, Any]) -> None:
        """
        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated.
        """
        ...

def Field(
    default: Any = ...,
    *,
    default_factory: Optional[NoArgAnyCallable] = ...,
    alias: str = ...,
    title: str = ...,
    description: str = ...,
    const: bool = ...,
    gt: float = ...,
    ge: float = ...,
    lt: float = ...,
    le: float = ...,
    multiple_of: float = ...,
    min_items: int = ...,
    max_items: int = ...,
    min_length: int = ...,
    max_length: int = ...,
    allow_mutation: bool = ...,
    regex: str = ...,
    **extra: Any
) -> Any:
    """
    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.

    :param default: since this is replacing the field’s default, its first argument is used
      to set the default, use ellipsis (``...``) to indicate the field is required
    :param default_factory: callable that will be called when a default value is needed for this field
      If both `default` and `default_factory` are set, an error is raised.
    :param alias: the public name of the field
    :param title: can be any string, used in the schema
    :param description: can be any string, used in the schema
    :param const: this field is required and *must* take it's default value
    :param gt: only applies to numbers, requires the field to be "greater than". The schema
      will have an ``exclusiveMinimum`` validation keyword
    :param ge: only applies to numbers, requires the field to be "greater than or equal to". The
      schema will have a ``minimum`` validation keyword
    :param lt: only applies to numbers, requires the field to be "less than". The schema
      will have an ``exclusiveMaximum`` validation keyword
    :param le: only applies to numbers, requires the field to be "less than or equal to". The
      schema will have a ``maximum`` validation keyword
    :param multiple_of: only applies to numbers, requires the field to be "a multiple of". The
      schema will have a ``multipleOf`` validation keyword
    :param min_length: only applies to strings, requires the field to have a minimum length. The
      schema will have a ``maximum`` validation keyword
    :param max_length: only applies to strings, requires the field to have a maximum length. The
      schema will have a ``maxLength`` validation keyword
    :param allow_mutation: a boolean which defaults to True. When False, the field raises a TypeError if the field is
      assigned on an instance.  The BaseModel Config must set validate_assignment to True
    :param regex: only applies to strings, requires the field match agains a regular expression
      pattern string. The schema will have a ``pattern`` validation keyword
    :param **extra: any additional keyword arguments will be added as is to the schema
    """
    ...

SHAPE_SINGLETON = ...
SHAPE_LIST = ...
SHAPE_SET = ...
SHAPE_MAPPING = ...
SHAPE_TUPLE = ...
SHAPE_TUPLE_ELLIPSIS = ...
SHAPE_SEQUENCE = ...
SHAPE_FROZENSET = ...
SHAPE_ITERABLE = ...
SHAPE_GENERIC = ...
SHAPE_DEQUE = ...
SHAPE_DICT = ...
SHAPE_DEFAULTDICT = ...
SHAPE_NAME_LOOKUP = ...
MAPPING_LIKE_SHAPES: Set[int] = ...

class ModelField(Representation):
    __slots__ = ...
    def __init__(
        self,
        *,
        name: str,
        type_: Type[Any],
        class_validators: Optional[Dict[str, Validator]],
        model_config: Type[BaseConfig],
        default: Any = ...,
        default_factory: Optional[NoArgAnyCallable] = ...,
        required: BoolUndefined = ...,
        alias: str = ...,
        field_info: Optional[FieldInfo] = ...
    ) -> None: ...
    def get_default(self) -> Any: ...
    @classmethod
    def infer(
        cls,
        *,
        name: str,
        value: Any,
        annotation: Any,
        class_validators: Optional[Dict[str, Validator]],
        config: Type[BaseConfig]
    ) -> ModelField: ...
    def set_config(self, config: Type[BaseConfig]) -> None: ...
    @property
    def alt_alias(self) -> bool: ...
    def prepare(self) -> None:
        """
        Prepare the field but inspecting self.default, self.type_ etc.

        Note: this method is **not** idempotent (because _type_analysis is not idempotent),
        e.g. calling it it multiple times may modify the field and configure it incorrectly.
        """
        ...
    def populate_validators(self) -> None:
        """
        Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_'s  __get_validators__
        and class validators. This method should be idempotent, e.g. it should be safe to call multiple times
        without mis-configuring the field.
        """
        ...
    def validate(
        self,
        v: Any,
        values: Dict[str, Any],
        *,
        loc: LocStr,
        cls: Optional[ModelOrDc] = ...
    ) -> ValidateReturn: ...
    def is_complex(self) -> bool:
        """
        Whether the field is "complex" eg. env variables should be parsed as JSON.
        """
        ...
    def __repr_args__(self) -> ReprArgs: ...

class ModelPrivateAttr(Representation):
    __slots__ = ...
    def __init__(
        self, default: Any = ..., *, default_factory: Optional[NoArgAnyCallable] = ...
    ) -> None: ...
    def get_default(self) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...

def PrivateAttr(
    default: Any = ..., *, default_factory: Optional[NoArgAnyCallable] = ...
) -> Any:
    """
    Indicates that attribute is only used internally and never mixed with regular fields.

    Types or values of private attrs are not checked by pydantic and it's up to you to keep them relevant.

    Private attrs are stored in model __slots__.

    :param default: the attribute’s default value
    :param default_factory: callable that will be called when a default value is needed for this attribute
      If both `default` and `default_factory` are set, an error is raised.
    """
    ...

class DeferredType:
    """
    Used to postpone field preparation, while creating recursive generic models.
    """

    ...
