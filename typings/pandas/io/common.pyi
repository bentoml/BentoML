import dataclasses
import zipfile
from collections import abc
from io import BytesIO
from typing import IO, Any, AnyStr
from pandas._typing import (
    Buffer,
    CompressionDict,
    CompressionOptions,
    FileOrBuffer,
    FilePathOrBuffer,
    StorageOptions,
)

lzma = ...
_VALID_URLS = ...

@dataclasses.dataclass
class IOArgs:
    filepath_or_buffer: FileOrBuffer
    encoding: str
    mode: str
    compression: CompressionDict
    should_close: bool = ...

@dataclasses.dataclass
class IOHandles:
    handle: Buffer
    compression: CompressionDict
    created_handles: list[Buffer] = ...
    is_wrapped: bool = ...
    is_mmap: bool = ...
    def close(self) -> None: ...
    def __enter__(self) -> IOHandles: ...
    def __exit__(self, *args: Any) -> None: ...

def is_url(url) -> bool: ...
def validate_header_arg(header) -> None: ...
def stringify_path(
    filepath_or_buffer: FilePathOrBuffer[AnyStr], convert_file_like: bool = ...
) -> FileOrBuffer[AnyStr]: ...
def urlopen(*args, **kwargs): ...
def is_fsspec_url(url: FilePathOrBuffer) -> bool: ...
def file_path_to_url(path: str) -> str: ...

_compression_to_extension = ...

def get_compression_method(
    compression: CompressionOptions,
) -> tuple[str | None, CompressionDict]: ...
def infer_compression(
    filepath_or_buffer: FilePathOrBuffer, compression: str | None
) -> str | None: ...
def get_handle(
    path_or_buf: FilePathOrBuffer,
    mode: str,
    encoding: str | None = ...,
    compression: CompressionOptions = ...,
    memory_map: bool = ...,
    is_text: bool = ...,
    errors: str | None = ...,
    storage_options: StorageOptions = ...,
) -> IOHandles: ...

class _BytesZipFile(zipfile.ZipFile, BytesIO):
    def __init__(
        self,
        file: FilePathOrBuffer,
        mode: str,
        archive_name: str | None = ...,
        **kwargs
    ) -> None: ...
    def write(self, data): ...
    def flush(self) -> None: ...
    def close(self): ...
    @property
    def closed(self): ...

class _MMapWrapper(abc.Iterator):
    def __init__(
        self, f: IO, encoding: str = ..., errors: str = ..., decode: bool = ...
    ) -> None: ...
    def __getattr__(self, name: str): ...
    def __iter__(self) -> _MMapWrapper: ...
    def read(self, size: int = ...) -> str | bytes: ...
    def __next__(self) -> str: ...

def file_exists(filepath_or_buffer: FilePathOrBuffer) -> bool: ...
