from typing import Optional
from ..file_utils import add_end_docstrings, is_tf_available, is_torch_available
from .base import PIPELINE_INIT_ARGS, Pipeline

if is_tf_available(): ...
if is_torch_available(): ...
logger = ...

@add_end_docstrings(PIPELINE_INIT_ARGS)
class Text2TextGenerationPipeline(Pipeline):
    return_name = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def check_inputs(self, input_length: int, min_length: int, max_length: int): ...
    def __call__(
        self,
        *args,
        return_tensors=...,
        return_text=...,
        clean_up_tokenization_spaces=...,
        truncation=...,
        **generate_kwargs
    ): ...

@add_end_docstrings(PIPELINE_INIT_ARGS)
class SummarizationPipeline(Text2TextGenerationPipeline):
    return_name = ...
    def __call__(self, *args, **kwargs): ...
    def check_inputs(
        self, input_length: int, min_length: int, max_length: int
    ) -> bool: ...

@add_end_docstrings(PIPELINE_INIT_ARGS)
class TranslationPipeline(Text2TextGenerationPipeline):
    return_name = ...
    src_lang: Optional[str] = ...
    tgt_lang: Optional[str] = ...
    def __init__(self, *args, src_lang=..., tgt_lang=..., **kwargs) -> None: ...
    def check_inputs(self, input_length: int, min_length: int, max_length: int): ...
    def __call__(
        self,
        *args,
        return_tensors=...,
        return_text=...,
        clean_up_tokenization_spaces=...,
        truncation=...,
        src_lang=...,
        tgt_lang=...,
        **generate_kwargs
    ): ...
