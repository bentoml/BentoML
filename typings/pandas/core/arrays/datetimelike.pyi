from typing import TYPE_CHECKING, Any, Callable, Literal, Sequence, Union, overload
import numpy as np
from pandas._libs.tslibs import NaTType
from pandas._typing import (
    ArrayLike,
    DatetimeLikeScalar,
    Dtype,
    DtypeObj,
    NpDtype,
    PositionalIndexer2D,
)
from pandas.core.arraylike import OpsMixin
from pandas.core.arrays import DatetimeArray, TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray, ravel_compat
from pandas.core.ops.common import unpack_zerodim_and_defer
from pandas.util._decorators import Appender, Substitution

if TYPE_CHECKING: ...
DTScalarOrNaT = Union[DatetimeLikeScalar, NaTType]
DatetimeLikeArrayT = ...

class InvalidComparison(Exception): ...

class DatetimeLikeArrayMixin(OpsMixin, NDArrayBackedExtensionArray):
    _infer_matches: tuple[str, ...]
    _is_recognized_dtype: Callable[[DtypeObj], bool]
    _recognized_scalars: tuple[type, ...]
    _ndarray: np.ndarray
    def __init__(self, data, dtype: Dtype | None = ..., freq=..., copy=...) -> None: ...
    def __iter__(self): ...
    @property
    def asi8(self) -> np.ndarray: ...
    def __array__(self, dtype: NpDtype | None = ...) -> np.ndarray: ...
    def __getitem__(
        self, key: PositionalIndexer2D
    ) -> DatetimeLikeArrayMixin | DTScalarOrNaT: ...
    def __setitem__(
        self,
        key: int | Sequence[int] | Sequence[bool] | slice,
        value: NaTType | Any | Sequence[Any],
    ) -> None: ...
    def astype(self, dtype, copy: bool = ...): ...
    @overload
    def view(self: DatetimeLikeArrayT) -> DatetimeLikeArrayT: ...
    @overload
    def view(self, dtype: Literal["M8[ns]"]) -> DatetimeArray: ...
    @overload
    def view(self, dtype: Literal["m8[ns]"]) -> TimedeltaArray: ...
    @overload
    def view(self, dtype: Dtype | None = ...) -> ArrayLike: ...
    def view(self, dtype: Dtype | None = ...) -> ArrayLike: ...
    def copy(self: DatetimeLikeArrayT) -> DatetimeLikeArrayT: ...
    @ravel_compat
    def map(self, mapper): ...
    def isin(self, values) -> np.ndarray: ...
    def isna(self) -> np.ndarray: ...
    @property
    def freq(self): ...
    @freq.setter
    def freq(self, value): ...
    @property
    def freqstr(self) -> str | None: ...
    @property
    def inferred_freq(self) -> str | None: ...
    @property
    def resolution(self) -> str: ...
    __pow__ = ...
    __rpow__ = ...
    __mul__ = ...
    __rmul__ = ...
    __truediv__ = ...
    __rtruediv__ = ...
    __floordiv__ = ...
    __rfloordiv__ = ...
    __mod__ = ...
    __rmod__ = ...
    __divmod__ = ...
    __rdivmod__ = ...
    _add_datetime_arraylike = ...
    _sub_datetime_arraylike = ...
    @unpack_zerodim_and_defer("__add__")
    def __add__(self, other): ...
    def __radd__(self, other): ...
    @unpack_zerodim_and_defer("__sub__")
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def min(self, *, axis: int | None = ..., skipna: bool = ..., **kwargs): ...
    def max(self, *, axis: int | None = ..., skipna: bool = ..., **kwargs): ...
    def mean(self, *, skipna: bool = ..., axis: int | None = ...): ...
    def median(self, *, axis: int | None = ..., skipna: bool = ..., **kwargs): ...

class DatelikeOps(DatetimeLikeArrayMixin):
    @Substitution(
        URL="""https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior"""
    )
    def strftime(self, date_format: str) -> np.ndarray: ...

_round_doc = ...
_round_example = ...
_floor_example = ...
_ceil_example = ...
TimelikeOpsT = ...

class TimelikeOps(DatetimeLikeArrayMixin):
    @Appender((_round_doc + _round_example).format(op="round"))
    def round(self, freq, ambiguous=..., nonexistent=...): ...
    @Appender((_round_doc + _floor_example).format(op="floor"))
    def floor(self, freq, ambiguous=..., nonexistent=...): ...
    @Appender((_round_doc + _ceil_example).format(op="ceil"))
    def ceil(self, freq, ambiguous=..., nonexistent=...): ...
    def any(self, *, axis: int | None = ..., skipna: bool = ...): ...
    def all(self, *, axis: int | None = ..., skipna: bool = ...): ...
    def factorize(self, na_sentinel=..., sort: bool = ...): ...

def validate_periods(periods): ...
def validate_endpoints(closed): ...
def validate_inferred_freq(freq, inferred_freq, freq_infer): ...
def maybe_infer_freq(freq): ...
