import re
from collections.abc import Callable
from typing import TYPE_CHECKING
from pandas import Index
from pandas._typing import FrameOrSeriesUnion
from pandas.core.base import NoNewAttributesMixin
from pandas.util._decorators import Appender

if TYPE_CHECKING: ...
_shared_docs: dict[str, str] = ...
_cpython_optimized_encoders = ...
_cpython_optimized_decoders = ...

def forbid_nonstring_types(forbidden, name=...): ...

class StringMethods(NoNewAttributesMixin):
    def __init__(self, data) -> None: ...
    def __getitem__(self, key): ...
    def __iter__(self): ...
    @forbid_nonstring_types(["bytes", "mixed", "mixed-integer"])
    def cat(self, others=..., sep=..., na_rep=..., join=...): ...
    @Appender(_shared_docs["str_split"] % {"side": "beginning", "method": "split"})
    @forbid_nonstring_types(["bytes"])
    def split(self, pat=..., n=..., expand=...): ...
    @Appender(_shared_docs["str_split"] % {"side": "end", "method": "rsplit"})
    @forbid_nonstring_types(["bytes"])
    def rsplit(self, pat=..., n=..., expand=...): ...
    @Appender(
        _shared_docs["str_partition"]
        % {
            "side": "first",
            "return": """3 elements containing the string itself, followed by two empty strings""",
            "also": "rpartition : Split the string at the last occurrence of `sep`.",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def partition(self, sep=..., expand=...): ...
    @Appender(
        _shared_docs["str_partition"]
        % {
            "side": "last",
            "return": """3 elements containing two empty strings, followed by the string itself""",
            "also": "partition : Split the string at the first occurrence of `sep`.",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def rpartition(self, sep=..., expand=...): ...
    def get(self, i): ...
    @forbid_nonstring_types(["bytes"])
    def join(self, sep): ...
    @forbid_nonstring_types(["bytes"])
    def contains(self, pat, case=..., flags=..., na=..., regex=...): ...
    @forbid_nonstring_types(["bytes"])
    def match(self, pat, case=..., flags=..., na=...): ...
    @forbid_nonstring_types(["bytes"])
    def fullmatch(self, pat, case=..., flags=..., na=...): ...
    @forbid_nonstring_types(["bytes"])
    def replace(
        self,
        pat: str | re.Pattern,
        repl: str | Callable,
        n: int = ...,
        case: bool | None = ...,
        flags: int = ...,
        regex: bool | None = ...,
    ): ...
    @forbid_nonstring_types(["bytes"])
    def repeat(self, repeats): ...
    @forbid_nonstring_types(["bytes"])
    def pad(self, width, side=..., fillchar=...): ...
    @Appender(_shared_docs["str_pad"] % {"side": "left and right", "method": "center"})
    @forbid_nonstring_types(["bytes"])
    def center(self, width, fillchar=...): ...
    @Appender(_shared_docs["str_pad"] % {"side": "right", "method": "ljust"})
    @forbid_nonstring_types(["bytes"])
    def ljust(self, width, fillchar=...): ...
    @Appender(_shared_docs["str_pad"] % {"side": "left", "method": "rjust"})
    @forbid_nonstring_types(["bytes"])
    def rjust(self, width, fillchar=...): ...
    @forbid_nonstring_types(["bytes"])
    def zfill(self, width): ...
    def slice(self, start=..., stop=..., step=...): ...
    @forbid_nonstring_types(["bytes"])
    def slice_replace(self, start=..., stop=..., repl=...): ...
    def decode(self, encoding, errors=...): ...
    @forbid_nonstring_types(["bytes"])
    def encode(self, encoding, errors=...): ...
    @Appender(
        _shared_docs["str_strip"]
        % {
            "side": "left and right sides",
            "method": "strip",
            "position": "leading and trailing",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def strip(self, to_strip=...): ...
    @Appender(
        _shared_docs["str_strip"]
        % {"side": "left side", "method": "lstrip", "position": "leading"}
    )
    @forbid_nonstring_types(["bytes"])
    def lstrip(self, to_strip=...): ...
    @Appender(
        _shared_docs["str_strip"]
        % {"side": "right side", "method": "rstrip", "position": "trailing"}
    )
    @forbid_nonstring_types(["bytes"])
    def rstrip(self, to_strip=...): ...
    @forbid_nonstring_types(["bytes"])
    def wrap(self, width, **kwargs): ...
    @forbid_nonstring_types(["bytes"])
    def get_dummies(self, sep=...): ...
    @forbid_nonstring_types(["bytes"])
    def translate(self, table): ...
    @forbid_nonstring_types(["bytes"])
    def count(self, pat, flags=...): ...
    @forbid_nonstring_types(["bytes"])
    def startswith(self, pat, na=...): ...
    @forbid_nonstring_types(["bytes"])
    def endswith(self, pat, na=...): ...
    @forbid_nonstring_types(["bytes"])
    def findall(self, pat, flags=...): ...
    @forbid_nonstring_types(["bytes"])
    def extract(
        self, pat: str, flags: int = ..., expand: bool = ...
    ) -> FrameOrSeriesUnion | Index: ...
    @forbid_nonstring_types(["bytes"])
    def extractall(self, pat, flags=...): ...
    @Appender(
        _shared_docs["find"]
        % {
            "side": "lowest",
            "method": "find",
            "also": "rfind : Return highest indexes in each strings.",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def find(self, sub, start=..., end=...): ...
    @Appender(
        _shared_docs["find"]
        % {
            "side": "highest",
            "method": "rfind",
            "also": "find : Return lowest indexes in each strings.",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def rfind(self, sub, start=..., end=...): ...
    @forbid_nonstring_types(["bytes"])
    def normalize(self, form): ...
    @Appender(
        _shared_docs["index"]
        % {
            "side": "lowest",
            "similar": "find",
            "method": "index",
            "also": "rindex : Return highest indexes in each strings.",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def index(self, sub, start=..., end=...): ...
    @Appender(
        _shared_docs["index"]
        % {
            "side": "highest",
            "similar": "rfind",
            "method": "rindex",
            "also": "index : Return lowest indexes in each strings.",
        }
    )
    @forbid_nonstring_types(["bytes"])
    def rindex(self, sub, start=..., end=...): ...
    def len(self): ...
    _doc_args: dict[str, dict[str, str]] = ...
    @Appender(_shared_docs["casemethods"] % _doc_args["lower"])
    @forbid_nonstring_types(["bytes"])
    def lower(self): ...
    @Appender(_shared_docs["casemethods"] % _doc_args["upper"])
    @forbid_nonstring_types(["bytes"])
    def upper(self): ...
    @Appender(_shared_docs["casemethods"] % _doc_args["title"])
    @forbid_nonstring_types(["bytes"])
    def title(self): ...
    @Appender(_shared_docs["casemethods"] % _doc_args["capitalize"])
    @forbid_nonstring_types(["bytes"])
    def capitalize(self): ...
    @Appender(_shared_docs["casemethods"] % _doc_args["swapcase"])
    @forbid_nonstring_types(["bytes"])
    def swapcase(self): ...
    @Appender(_shared_docs["casemethods"] % _doc_args["casefold"])
    @forbid_nonstring_types(["bytes"])
    def casefold(self): ...
    isalnum = ...
    isalpha = ...
    isdigit = ...
    isspace = ...
    islower = ...
    isupper = ...
    istitle = ...
    isnumeric = ...
    isdecimal = ...

def cat_safe(list_of_columns: list, sep: str): ...
def cat_core(list_of_columns: list, sep: str): ...
