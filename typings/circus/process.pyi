"""
This type stub file was generated by pyright.
"""

from circus.util import debuglog

_INFOLINE = ...
RUNNING = ...
DEAD_OR_ZOMBIE = ...
UNEXISTING = ...
OTHER = ...
def get_children(proc, recursive=...):
    ...

def get_memory_info(proc):
    ...

def get_cpu_percent(proc, **kw):
    ...

def get_memory_percent(proc):
    ...

def get_cpu_times(proc):
    ...

def get_nice(proc):
    ...

def get_cmdline(proc):
    ...

def get_create_time(proc):
    ...

def get_username(proc):
    ...

def get_status(proc):
    ...

class Process:
    """Wraps a process.

    Options:

    - **wid**: the process unique identifier. This value will be used to
      replace the *$WID* string in the command line if present.

    - **cmd**: the command to run. May contain any of the variables available
      that are being passed to this class. They will be replaced using the
      python format syntax.

    - **args**: the arguments for the command to run. Can be a list or
      a string. If **args** is  a string, it's splitted using
      :func:`shlex.split`. Defaults to None.

    - **executable**: When executable is given, the first item in
      the args sequence obtained from **cmd** is still treated by most
      programs as the command name, which can then be different from the
      actual executable name. It becomes the display name for the executing
      program in utilities such as **ps**.

    - **working_dir**: the working directory to run the command in. If
      not provided, will default to the current working directory.

    - **shell**: if *True*, will run the command in the shell
      environment. *False* by default. **warning: this is a
      security hazard**.

    - **uid**: if given, is the user id or name the command should run
      with. The current uid is the default.

    - **gid**: if given, is the group id or name the command should run
      with. The current gid is the default.

    - **env**: a mapping containing the environment variables the command
      will run with. Optional.

    - **rlimits**: a mapping containing rlimit names and values that will
      be set before the command runs.

    - **use_fds**: if True, will not close the fds in the subprocess. Must be
      be set to True on Windows if stdout or stderr are redirected.
      default: False.

    - **pipe_stdout**: if True, will open a PIPE on stdout. default: True.

    - **pipe_stderr**: if True, will open a PIPE on stderr. default: True.

    - **close_child_stdin**: If True, redirects the child process' stdin
      to /dev/null after the fork. default: True.

    - **close_child_stdout**: If True, redirects the child process' stdout
      to /dev/null after the fork. default: False.

    - **close_child_stderr**: If True, redirects the child process' stdout
      to /dev/null after the fork. default: False.
    """
    def __init__(self, name, wid, cmd, args=..., working_dir=..., shell=..., uid=..., gid=..., env=..., rlimits=..., executable=..., use_fds=..., watcher=..., spawn=..., pipe_stdout=..., pipe_stderr=..., close_child_stdin=..., close_child_stdout=..., close_child_stderr=...) -> None:
        ...
    
    def spawn(self): # -> None:
        ...
    
    def format_args(self, sockets_fds=...):
        """ It's possible to use environment variables and some other variables
        that are available in this context, when spawning the processes.
        """
        ...
    
    def returncode(self): # -> Any:
        ...
    
    @debuglog
    def poll(self): # -> Any:
        ...
    
    @debuglog
    def is_alive(self): # -> bool:
        ...
    
    @debuglog
    def send_signal(self, sig): # -> None:
        """Sends a signal **sig** to the process."""
        ...
    
    @debuglog
    def stop(self): # -> None:
        """Stop the process and close stdout/stderr

        If the corresponding process is still here
        (normally it's already killed by the watcher),
        a SIGTERM is sent, then a SIGKILL after 1 second.

        The shutdown process (SIGTERM then SIGKILL) is
        normally taken by the watcher. So if the process
        is still there here, it's a kind of bad behavior
        because the graceful timeout won't be respected here.
        """
        ...
    
    def close_output_channels(self): # -> None:
        ...
    
    def wait(self, timeout=...): # -> None:
        """
        Wait for the process to terminate, in the fashion
        of waitpid.

        Accepts a timeout in seconds.
        """
        ...
    
    def age(self): # -> float:
        """Return the age of the process in seconds."""
        ...
    
    def info(self): # -> dict[Unknown, Unknown] | Literal['No such process (stopped?)']:
        """Return process info.

        The info returned is a mapping with these keys:

        - **mem_info1**: Resident Set Size Memory in bytes (RSS)
        - **mem_info2**: Virtual Memory Size in bytes (VMS).
        - **cpu**: % of cpu usage.
        - **mem**: % of memory usage.
        - **ctime**: process CPU (user + system) time in seconds.
        - **pid**: process id.
        - **username**: user name that owns the process.
        - **nice**: process niceness (between -20 and 20)
        - **cmdline**: the command line the process was run with.
        """
        ...
    
    def children(self, recursive=...): # -> list[int | Any]:
        """Return a list of children pids."""
        ...
    
    def is_child(self, pid): # -> bool:
        """Return True is the given *pid* is a child of that process."""
        ...
    
    @debuglog
    def send_signal_child(self, pid, signum): # -> None:
        """Send signal *signum* to child *pid*."""
        ...
    
    @debuglog
    def send_signal_children(self, signum, recursive=...):
        """Send signal *signum* to all children."""
        ...
    
    @property
    def status(self): # -> Literal[1, 2, 0, 3]:
        """Return the process status as a constant

        - RUNNING
        - DEAD_OR_ZOMBIE
        - UNEXISTING
        - OTHER
        """
        ...
    
    @property
    def pid(self): # -> int:
        """Return the *pid*"""
        ...
    
    @property
    def stdout(self): # -> Any:
        """Return the *stdout* stream"""
        ...
    
    @property
    def stderr(self): # -> Any:
        """Return the *stdout* stream"""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    


