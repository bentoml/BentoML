from typing import TYPE_CHECKING, Any, Callable
import numpy as np
from pandas import Float64Index, Index
from pandas._libs import internals as libinternals
from pandas._libs.internals import BlockPlacement
from pandas._typing import ArrayLike, Dtype, DtypeObj, F, Shape, final
from pandas.core.arrays import DatetimeArray, ExtensionArray, TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray
from pandas.core.base import PandasObject
from pandas.util._decorators import cache_readonly

if TYPE_CHECKING: ...
_dtype_obj = ...

def maybe_split(meth: F) -> F: ...

class Block(PandasObject):
    values: np.ndarray | ExtensionArray
    ndim: int
    __init__: Callable
    __slots__ = ...
    is_numeric = ...
    is_object = ...
    is_extension = ...
    _can_consolidate = ...
    _validate_ndim = ...
    @property
    def is_view(self) -> bool: ...
    @final
    @cache_readonly
    def is_categorical(self) -> bool: ...
    @final
    @property
    def is_bool(self) -> bool: ...
    @final
    def external_values(self): ...
    @property
    def array_values(self) -> ExtensionArray: ...
    def get_values(self, dtype: DtypeObj | None = ...) -> np.ndarray: ...
    @final
    @cache_readonly
    def fill_value(self): ...
    @property
    def mgr_locs(self) -> BlockPlacement: ...
    @mgr_locs.setter
    def mgr_locs(self, new_mgr_locs: BlockPlacement): ...
    @final
    def make_block(self, values, placement=...) -> Block: ...
    @final
    def make_block_same_class(
        self, values, placement: BlockPlacement | None = ...
    ) -> Block: ...
    @final
    def __repr__(self) -> str: ...
    @final
    def __len__(self) -> int: ...
    @final
    def getitem_block(self, slicer) -> Block: ...
    def getitem_block_index(self, slicer: slice) -> Block: ...
    @final
    def getitem_block_columns(self, slicer, new_mgr_locs: BlockPlacement) -> Block: ...
    @property
    def shape(self) -> Shape: ...
    @cache_readonly
    def dtype(self) -> DtypeObj: ...
    def iget(self, i): ...
    def set_inplace(self, locs, values): ...
    def delete(self, loc) -> None: ...
    @final
    def apply(self, func, **kwargs) -> list[Block]: ...
    def reduce(self, func, ignore_failures: bool = ...) -> list[Block]: ...
    def fillna(
        self, value, limit=..., inplace: bool = ..., downcast=...
    ) -> list[Block]: ...
    @final
    def split_and_operate(self, func, *args, **kwargs) -> list[Block]: ...
    @final
    def downcast(self, dtypes=...) -> list[Block]: ...
    @final
    def astype(self, dtype, copy: bool = ..., errors: str = ...): ...
    def convert(
        self,
        copy: bool = ...,
        datetime: bool = ...,
        numeric: bool = ...,
        timedelta: bool = ...,
    ) -> list[Block]: ...
    @final
    def should_store(self, value: ArrayLike) -> bool: ...
    @final
    def to_native_types(self, na_rep=..., quoting=..., **kwargs): ...
    @final
    def copy(self, deep: bool = ...): ...
    @final
    def replace(
        self, to_replace, value, inplace: bool = ..., regex: bool = ...
    ) -> list[Block]: ...
    def setitem(self, indexer, value): ...
    def putmask(self, mask, new) -> list[Block]: ...
    @final
    def coerce_to_target_dtype(self, other) -> Block: ...
    def interpolate(
        self,
        method: str = ...,
        axis: int = ...,
        index: Index | None = ...,
        inplace: bool = ...,
        limit: int | None = ...,
        limit_direction: str = ...,
        limit_area: str | None = ...,
        fill_value: Any | None = ...,
        coerce: bool = ...,
        downcast: str | None = ...,
        **kwargs
    ) -> list[Block]: ...
    def take_nd(
        self,
        indexer,
        axis: int,
        new_mgr_locs: BlockPlacement | None = ...,
        fill_value=...,
    ) -> Block: ...
    def diff(self, n: int, axis: int = ...) -> list[Block]: ...
    def shift(
        self, periods: int, axis: int = ..., fill_value: Any = ...
    ) -> list[Block]: ...
    def where(self, other, cond, errors=...) -> list[Block]: ...
    @final
    def quantile(
        self, qs: Float64Index, interpolation=..., axis: int = ...
    ) -> Block: ...

class EABackedBlock(Block):
    values: ExtensionArray
    def delete(self, loc) -> None: ...
    @cache_readonly
    def array_values(self) -> ExtensionArray: ...
    def get_values(self, dtype: DtypeObj | None = ...) -> np.ndarray: ...
    def interpolate(
        self, method=..., axis=..., inplace=..., limit=..., fill_value=..., **kwargs
    ): ...

class ExtensionBlock(libinternals.Block, EABackedBlock):
    _can_consolidate = ...
    _validate_ndim = ...
    is_extension = ...
    values: ExtensionArray
    @cache_readonly
    def shape(self) -> Shape: ...
    def iget(self, col): ...
    def set_inplace(self, locs, values): ...
    def putmask(self, mask, new) -> list[Block]: ...
    @property
    def is_view(self) -> bool: ...
    @cache_readonly
    def is_numeric(self): ...
    def setitem(self, indexer, value): ...
    def take_nd(
        self,
        indexer,
        axis: int = ...,
        new_mgr_locs: BlockPlacement | None = ...,
        fill_value=...,
    ) -> Block: ...
    @final
    def getitem_block_index(self, slicer: slice) -> ExtensionBlock: ...
    def fillna(
        self, value, limit=..., inplace: bool = ..., downcast=...
    ) -> list[Block]: ...
    def diff(self, n: int, axis: int = ...) -> list[Block]: ...
    def shift(
        self, periods: int, axis: int = ..., fill_value: Any = ...
    ) -> list[Block]: ...
    def where(self, other, cond, errors=...) -> list[Block]: ...

class NumpyBlock(libinternals.NumpyBlock, Block):
    values: np.ndarray
    getitem_block_index = ...

class NumericBlock(NumpyBlock):
    __slots__ = ...
    is_numeric = ...

class NDArrayBackedExtensionBlock(libinternals.NDArrayBackedBlock, EABackedBlock):
    values: NDArrayBackedExtensionArray
    getitem_block_index = ...
    @property
    def is_view(self) -> bool: ...
    def setitem(self, indexer, value): ...
    def putmask(self, mask, new) -> list[Block]: ...
    def where(self, other, cond, errors=...) -> list[Block]: ...
    def diff(self, n: int, axis: int = ...) -> list[Block]: ...
    def shift(
        self, periods: int, axis: int = ..., fill_value: Any = ...
    ) -> list[Block]: ...
    def fillna(
        self, value, limit=..., inplace: bool = ..., downcast=...
    ) -> list[Block]: ...

class DatetimeLikeBlock(NDArrayBackedExtensionBlock):
    __slots__ = ...
    is_numeric = ...
    values: DatetimeArray | TimedeltaArray

class DatetimeTZBlock(DatetimeLikeBlock):
    values: DatetimeArray
    __slots__ = ...
    is_extension = ...
    _validate_ndim = ...
    _can_consolidate = ...

class ObjectBlock(NumpyBlock):
    __slots__ = ...
    is_object = ...
    @maybe_split
    def reduce(self, func, ignore_failures: bool = ...) -> list[Block]: ...
    @maybe_split
    def convert(
        self,
        copy: bool = ...,
        datetime: bool = ...,
        numeric: bool = ...,
        timedelta: bool = ...,
    ) -> list[Block]: ...

class CategoricalBlock(ExtensionBlock):
    __slots__ = ...
    @property
    def dtype(self) -> DtypeObj: ...

def maybe_coerce_values(values) -> ArrayLike: ...
def get_block_type(values, dtype: Dtype | None = ...): ...
def new_block(values, placement, *, ndim: int, klass=...) -> Block: ...
def check_ndim(values, placement: BlockPlacement, ndim: int): ...
def extract_pandas_array(
    values: np.ndarray | ExtensionArray, dtype: DtypeObj | None, ndim: int
) -> tuple[np.ndarray | ExtensionArray, DtypeObj | None]: ...
def extend_blocks(result, blocks=...) -> list[Block]: ...
def ensure_block_shape(values: ArrayLike, ndim: int = ...) -> ArrayLike: ...
def to_native_types(
    values: ArrayLike,
    *,
    na_rep=...,
    quoting=...,
    float_format=...,
    decimal=...,
    **kwargs
) -> np.ndarray: ...
def external_values(values: ArrayLike) -> ArrayLike: ...
