from typing import TYPE_CHECKING
import numpy as np
from pandas import Index
from pandas._typing import ArrayLike, Dtype, NpDtype, Ordered, Scalar
from pandas.core.accessor import PandasDelegate, delegate_names
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray
from pandas.core.base import NoNewAttributesMixin, PandasObject
from pandas.core.dtypes.dtypes import CategoricalDtype
from pandas.core.strings.object_array import ObjectStringArrayMixin
from pandas.util._decorators import cache_readonly, deprecate_kwarg

if TYPE_CHECKING: ...
CategoricalT = ...

def contains(cat, key, container): ...

class Categorical(NDArrayBackedExtensionArray, PandasObject, ObjectStringArrayMixin):
    __array_priority__ = ...
    _hidden_attrs = ...
    _typ = ...
    _dtype: CategoricalDtype
    def __init__(
        self,
        values,
        categories=...,
        ordered=...,
        dtype: Dtype | None = ...,
        fastpath=...,
        copy: bool = ...,
    ) -> None: ...
    @property
    def dtype(self) -> CategoricalDtype: ...
    def astype(self, dtype: Dtype, copy: bool = ...) -> ArrayLike: ...
    @cache_readonly
    def itemsize(self) -> int: ...
    def tolist(self) -> list[Scalar]: ...
    to_list = ...
    @classmethod
    def from_codes(
        cls, codes, categories=..., ordered=..., dtype: Dtype | None = ...
    ): ...
    @property
    def categories(self): ...
    @categories.setter
    def categories(self, categories): ...
    @property
    def ordered(self) -> Ordered: ...
    @property
    def codes(self) -> np.ndarray: ...
    def set_ordered(self, value, inplace=...): ...
    def as_ordered(self, inplace=...): ...
    def as_unordered(self, inplace=...): ...
    def set_categories(self, new_categories, ordered=..., rename=..., inplace=...): ...
    def rename_categories(self, new_categories, inplace=...): ...
    def reorder_categories(self, new_categories, ordered=..., inplace=...): ...
    def add_categories(self, new_categories, inplace=...): ...
    def remove_categories(self, removals, inplace=...): ...
    def remove_unused_categories(self, inplace=...): ...
    def map(self, mapper): ...
    __eq__ = ...
    __ne__ = ...
    __lt__ = ...
    __gt__ = ...
    __le__ = ...
    __ge__ = ...
    def __array__(self, dtype: NpDtype | None = ...) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def __setstate__(self, state): ...
    @property
    def nbytes(self) -> int: ...
    def memory_usage(self, deep: bool = ...) -> int: ...
    def isna(self) -> np.ndarray: ...
    isnull = ...
    def notna(self) -> np.ndarray: ...
    notnull = ...
    def value_counts(self, dropna: bool = ...): ...
    def check_for_ordered(self, op): ...
    def argsort(self, ascending=..., kind=..., **kwargs): ...
    def sort_values(
        self, inplace: bool = ..., ascending: bool = ..., na_position: str = ...
    ): ...
    def view(self, dtype=...): ...
    def to_dense(self) -> np.ndarray: ...
    def take_nd(self, indexer, allow_fill: bool = ..., fill_value=...): ...
    def __iter__(self): ...
    def __contains__(self, key) -> bool: ...
    def __repr__(self) -> str: ...
    def __getitem__(self, key): ...
    @deprecate_kwarg(old_arg_name="numeric_only", new_arg_name="skipna")
    def min(self, *, skipna=..., **kwargs): ...
    @deprecate_kwarg(old_arg_name="numeric_only", new_arg_name="skipna")
    def max(self, *, skipna=..., **kwargs): ...
    def mode(self, dropna=...): ...
    def unique(self): ...
    def equals(self, other: object) -> bool: ...
    def is_dtype_equal(self, other) -> bool: ...
    def describe(self): ...
    def isin(self, values) -> np.ndarray: ...
    def replace(self, to_replace, value, inplace: bool = ...): ...

@delegate_names(
    delegate=Categorical, accessors=["categories", "ordered"], typ="property"
)
@delegate_names(
    delegate=Categorical,
    accessors=[
        "rename_categories",
        "reorder_categories",
        "add_categories",
        "remove_categories",
        "remove_unused_categories",
        "set_categories",
        "as_ordered",
        "as_unordered",
    ],
    typ="method",
)
class CategoricalAccessor(PandasDelegate, PandasObject, NoNewAttributesMixin):
    def __init__(self, data) -> None: ...
    @property
    def codes(self): ...

def recode_for_categories(
    codes: np.ndarray, old_categories, new_categories, copy: bool = ...
) -> np.ndarray: ...
def factorize_from_iterable(values) -> tuple[np.ndarray, Index]: ...
def factorize_from_iterables(iterables) -> tuple[list[np.ndarray], list[Index]]: ...
