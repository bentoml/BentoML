"""
This type stub file was generated by pyright.
"""

import sys
from typing import AbstractSet, Any
from typing import Callable as TypingCallable
from typing import (
    Dict,
    ForwardRef,
    Generator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    Union,
)

if sys.version_info >= (3,8):
    from typing import Literal
else:
    from typing_extensions import Literal


def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:...

if sys.version_info < (3, 7):
    from typing import Callable as Callable

    AnyCallable = Callable[..., Any]
    NoArgAnyCallable = Callable[[], Any]
else:
    from collections.abc import Callable as Callable
    AnyCallable = TypingCallable[..., Any]
    NoArgAnyCallable = TypingCallable[[], Any]
AnnotatedTypeNames = {'AnnotatedMeta', '_AnnotatedAlias'}

from .fields import ModelField
TupleGenerator = Generator[Tuple[str, Any], None, None]
DictStrAny = Dict[str, Any]
DictAny = Dict[Any, Any]
SetStr = Set[str]
ListStr = List[str]
IntStr = Union[int, str]
AbstractSetIntStr = AbstractSet[IntStr]
DictIntStrAny = Dict[IntStr, Any]
MappingIntStrAny = Mapping[IntStr, Any]
CallableGenerator = Generator[AnyCallable, None, None]
ReprArgs = Sequence[Tuple[Optional[str], Any]]
__all__ = (
    "ForwardRef",
    "Callable",
    "AnyCallable",
    "NoArgAnyCallable",
    "NoneType",
    "NONE_TYPES",
    "display_as_type",
    "resolve_annotations",
    "is_callable_type",
    "is_literal_type",
    "all_literal_values",
    "is_namedtuple",
    "is_typeddict",
    "is_new_type",
    "new_type_supertype",
    "is_classvar",
    "update_field_forward_refs",
    "TupleGenerator",
    "DictStrAny",
    "DictAny",
    "SetStr",
    "ListStr",
    "IntStr",
    "AbstractSetIntStr",
    "DictIntStrAny",
    "CallableGenerator",
    "ReprArgs",
    "CallableGenerator",
    "GenericAlias",
    "get_args",
    "get_origin",
    "typing_base",
    "get_all_type_hints",
)
NoneType = None.__class__
NONE_TYPES: Set[Any] = {None, NoneType, Literal[None]}

def display_as_type(v: Type[Any]) -> str: ...
def resolve_annotations(
    raw_annotations: Dict[str, Type[Any]], module_name: Optional[str]
) -> Dict[str, Type[Any]]:
    """
    Partially taken from typing.get_type_hints.

    Resolve string or ForwardRef annotations into type objects if possible.
    """
    ...

def is_callable_type(type_: Type[Any]) -> bool: ...

if sys.version_info >= (3, 7):
    def is_literal_type(type_: Type[Any]) -> bool: ...
    def literal_values(type_: Type[Any]) -> Tuple[Any, ...]: ...

else: ...

def all_literal_values(type_: Type[Any]) -> Tuple[Any, ...]:
    """
    This method is used to retrieve all Literal values as
    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
    e.g. `Literal[Literal[Literal[1, 2, 3], "foo"], 5, None]`
    """
    ...

def is_namedtuple(type_: Type[Any]) -> bool:
    """
    Check if a given class is a named tuple.
    It can be either a `typing.NamedTuple` or `collections.namedtuple`
    """
    ...

def is_typeddict(type_: Type[Any]) -> bool:
    """
    Check if a given class is a typed dict (from `typing` or `typing_extensions`)
    In 3.10, there will be a public method (https://docs.python.org/3.10/library/typing.html#typing.is_typeddict)
    """
    ...

test_type = ...

def is_new_type(type_: Type[Any]) -> bool:
    """
    Check whether type_ was created using typing.NewType
    """
    ...

def new_type_supertype(type_: Type[Any]) -> Type[Any]: ...
def is_classvar(ann_type: Type[Any]) -> bool: ...
def update_field_forward_refs(field: ModelField, globalns: Any, localns: Any) -> None:
    """
    Try to update ForwardRefs on fields based on this ModelField, globalns and localns.
    """
    ...

def get_class(type_: Type[Any]) -> Union[None, bool, Type[Any]]:
    """
    Tries to get the class of a Type[T] annotation. Returns True if Type is used
    without brackets. Otherwise returns None.
    """
    ...
