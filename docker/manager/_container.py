import os
import re
import typing as t
import logging
from typing import TYPE_CHECKING
from pathlib import Path

import yaml
import attrs
from simple_di import container
from yamlinclude import YamlIncludeConstructor
from manager._utils import raise_exception
from manager.exceptions import ManagerException
from simple_di.providers import SingletonFactory

if TYPE_CHECKING:
    from manager._types import GenericDict
    from manager._types import GenericNestedDict

logger = logging.getLogger(__name__)

MANIFEST_GENERATED_STRING = "# NOTE: Partially generated by `manager create_manifest`\n"

DOCKER_DIRECTORY = Path(os.path.dirname(__file__)).parent
MANAGER_DIRECTORY = DOCKER_DIRECTORY.joinpath("manager")
MANIFEST_DIRECTORY = DOCKER_DIRECTORY.joinpath("manifest")

# release entry should always include CUDA support :)
RELEASE_PREFIX = "w_cuda_v"
RELEASE_KEY_RGX = re.compile(rf"{RELEASE_PREFIX}([\d\.]+)(?:_(\w+))?$")


YamlIncludeConstructor.add_to_loader_class(
    loader_class=yaml.FullLoader, base_dir=MANAGER_DIRECTORY.as_posix()
)


def load_manifest_yaml(package: str) -> "GenericDict":
    file = MANIFEST_DIRECTORY.joinpath(f"{package}.yml")
    if not file.exists():
        raise ManagerException(f"{file} doesn't exist under manifest directory.")
    with file.open("r", encoding="utf-8") as f:
        if f.readline() != MANIFEST_GENERATED_STRING:
            logger.exception(
                f"{package} should be initially generated with `manager create_manifest`"
            )
        manifest = yaml.load(f, Loader=yaml.FullLoader)
        manifest.pop("common")

    return manifest


@raise_exception
def _provider_converter(provider: str) -> str:
    if "quay" in provider.lower():
        assert provider in os.environ
        return "quay"
    return provider


@attrs.define
class RegistryCtx:
    name: str
    user: str
    password: str
    url: str
    provider: str = attrs.field(converter=_provider_converter)


@raise_exception
def get_registry_context(
    *,
    package: t.Optional[str] = None,
    org_name: str = "bentoml",
    default_manifest: "t.Optional[GenericDict]" = None,
) -> "t.List[RegistryCtx]":
    if package is not None:
        manifest = load_manifest_yaml(package)
    else:
        manifest = default_manifest
    if manifest is None:
        raise ManagerException("neither `package` nor `default_manifest` is passed.")

    # manifest should only have releases versions + registries
    for k in manifest:
        if RELEASE_KEY_RGX.match(k):
            manifest.pop(k)

    return [
        RegistryCtx(
            name=reg,
            user=reg_ctx["user"],
            password=reg_ctx["password"],
            provider=reg_ctx["provider"],
            url=reg_ctx["url"].format(org_name=org_name, repo_name=package),
        )
        for reg, reg_ctx in manifest.items()
    ]


@raise_exception
def get_general_context(
    *,
    package: t.Optional[str] = None,
    default_manifest: "t.Optional[GenericDict]" = None,
) -> "GenericNestedDict":
    if package is not None:
        manifest = load_manifest_yaml(package)
    else:
        manifest = default_manifest
    if manifest is None:
        raise ManagerException("neither `package` nor `default_manifest` is passed.")

    return {k: v for k, v in manifest.items() if RELEASE_KEY_RGX.match(k)}


@container
class ManagerContainerClass:

    docker_dir = DOCKER_DIRECTORY
    manager_dir = MANAGER_DIRECTORY
    manifest_dir = MANIFEST_DIRECTORY

    template_dir = DOCKER_DIRECTORY.joinpath("templates")
    generated_dir = DOCKER_DIRECTORY.joinpath("generated")
    tests_dir = DOCKER_DIRECTORY.joinpath("tests")

    bento_server_name = "bento-server"

    @SingletonFactory
    @staticmethod
    def bento_server_manifest():
        return load_manifest_yaml("bento-server")

    @SingletonFactory
    @staticmethod
    def bento_server_registry_ctx():
        return get_registry_context(package="bento-server")

    @SingletonFactory
    @staticmethod
    def bento_server_general_ctx():
        return get_general_context(package="bento-server")


ManagerContainer = ManagerContainerClass()
