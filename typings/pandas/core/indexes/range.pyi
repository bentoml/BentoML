from typing import TYPE_CHECKING, Any, Hashable
import numpy as np
from pandas._typing import Dtype
from pandas.core.indexes.numeric import Int64Index, NumericIndex
from pandas.core.ops.common import unpack_zerodim_and_defer
from pandas.util._decorators import cache_readonly, doc

if TYPE_CHECKING: ...
_empty_range = ...

class RangeIndex(NumericIndex):
    _typ = ...
    _engine_type = ...
    _dtype_validation_metadata = ...
    _range: range
    def __new__(
        cls,
        start=...,
        stop=...,
        step=...,
        dtype: Dtype | None = ...,
        copy: bool = ...,
        name: Hashable = ...,
    ) -> RangeIndex: ...
    @classmethod
    def from_range(
        cls, data: range, name=..., dtype: Dtype | None = ...
    ) -> RangeIndex: ...
    def __reduce__(self): ...
    _deprecation_message = ...
    @property
    def start(self) -> int: ...
    @property
    def stop(self) -> int: ...
    @property
    def step(self) -> int: ...
    @cache_readonly
    def nbytes(self) -> int: ...
    def memory_usage(self, deep: bool = ...) -> int: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def is_unique(self) -> bool: ...
    @cache_readonly
    def is_monotonic_increasing(self) -> bool: ...
    @cache_readonly
    def is_monotonic_decreasing(self) -> bool: ...
    def __contains__(self, key: Any) -> bool: ...
    @property
    def inferred_type(self) -> str: ...
    @doc(Int64Index.get_loc)
    def get_loc(self, key, method=..., tolerance=...): ...
    def repeat(self, repeats, axis=...) -> Int64Index: ...
    def delete(self, loc) -> Int64Index: ...
    def take(
        self, indices, axis: int = ..., allow_fill: bool = ..., fill_value=..., **kwargs
    ) -> Int64Index: ...
    def tolist(self) -> list[int]: ...
    @doc(Int64Index.__iter__)
    def __iter__(self): ...
    @doc(Int64Index.copy)
    def copy(
        self,
        name: Hashable = ...,
        deep: bool = ...,
        dtype: Dtype | None = ...,
        names=...,
    ): ...
    def min(self, axis=..., skipna: bool = ..., *args, **kwargs) -> int: ...
    def max(self, axis=..., skipna: bool = ..., *args, **kwargs) -> int: ...
    def argsort(self, *args, **kwargs) -> np.ndarray: ...
    def factorize(
        self, sort: bool = ..., na_sentinel: int | None = ...
    ) -> tuple[np.ndarray, RangeIndex]: ...
    def equals(self, other: object) -> bool: ...
    def symmetric_difference(self, other, result_name: Hashable = ..., sort=...): ...
    def __len__(self) -> int: ...
    @property
    def size(self) -> int: ...
    def __getitem__(self, key): ...
    @unpack_zerodim_and_defer("__floordiv__")
    def __floordiv__(self, other): ...
    def all(self, *args, **kwargs) -> bool: ...
    def any(self, *args, **kwargs) -> bool: ...
