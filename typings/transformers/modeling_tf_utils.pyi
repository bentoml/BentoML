import os
from typing import Dict, List, Optional, Union
import numpy as np
import tensorflow as tf
from .configuration_utils import PretrainedConfig
from .file_utils import PushToHubMixin
from .generation_tf_utils import TFGenerationMixin

logger = ...
tf_logger = ...
TFModelInputType = Union[
    List[tf.Tensor],
    List[np.ndarray],
    Dict[str, tf.Tensor],
    Dict[str, np.ndarray],
    np.ndarray,
    tf.Tensor,
]

class TFModelUtilsMixin:
    def num_parameters(self, only_trainable: bool = ...) -> int: ...

def keras_serializable(cls): ...

class TFCausalLanguageModelingLoss:
    def compute_loss(self, labels, logits): ...

class TFQuestionAnsweringLoss:
    def compute_loss(self, labels, logits): ...

class TFTokenClassificationLoss:
    def compute_loss(self, labels, logits): ...

class TFSequenceClassificationLoss:
    def compute_loss(self, labels, logits): ...

class TFMultipleChoiceLoss(TFSequenceClassificationLoss): ...
class TFMaskedLanguageModelingLoss(TFCausalLanguageModelingLoss): ...

class TFNextSentencePredictionLoss:
    def compute_loss(self, labels, logits): ...

def booleans_processing(config, **kwargs): ...
def input_processing(func, config, input_ids, **kwargs): ...
def load_tf_weights(
    model, resolved_archive_file, ignore_mismatched_sizes=..., _prefix=...
): ...
def init_copy_embeddings(old_embeddings, new_num_tokens): ...

class TFPreTrainedModel(
    tf.keras.Model, TFModelUtilsMixin, TFGenerationMixin, PushToHubMixin
):
    config_class = ...
    base_model_prefix = ...
    _keys_to_ignore_on_load_missing = ...
    _keys_to_ignore_on_load_unexpected = ...
    _requires_load_weight_prefix = ...
    @property
    def dummy_inputs(self) -> Dict[str, tf.Tensor]: ...
    def __init__(self, config, *inputs, **kwargs) -> None: ...
    @tf.function(
        input_signature=[
            {
                "input_ids": tf.TensorSpec((None, None), tf.int32, name="input_ids"),
                "attention_mask": tf.TensorSpec(
                    (None, None), tf.int32, name="attention_mask"
                ),
                "token_type_ids": tf.TensorSpec(
                    (None, None), tf.int32, name="token_type_ids"
                ),
            }
        ]
    )
    def serving(self, inputs): ...
    def serving_output(output): ...
    def get_input_embeddings(self) -> tf.keras.layers.Layer: ...
    def set_input_embeddings(self, value): ...
    def get_output_embeddings(self) -> Union[None, tf.keras.layers.Layer]: ...
    def set_output_embeddings(self, value): ...
    def get_output_layer_with_bias(self) -> Union[None, tf.keras.layers.Layer]: ...
    def get_prefix_bias_name(self) -> Union[None, str]: ...
    def get_bias(self) -> Union[None, Dict[str, tf.Variable]]: ...
    def set_bias(self, value): ...
    def get_lm_head(self) -> tf.keras.layers.Layer: ...
    def resize_token_embeddings(self, new_num_tokens=...) -> tf.Variable: ...
    def prune_heads(self, heads_to_prune): ...
    def save_pretrained(
        self,
        save_directory: Union[str, os.PathLike[str]],
        saved_model: bool = ...,
        version: int = ...,
        push_to_hub: bool = ...,
        **kwargs: Any
    ) -> None: ...
    @classmethod
    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs): ...

class TFConv1D(tf.keras.layers.Layer):
    def __init__(self, nf, nx, initializer_range=..., **kwargs) -> None: ...
    def build(self, input_shape): ...
    def call(self, x): ...

class TFSharedEmbeddings(tf.keras.layers.Layer):
    def __init__(
        self,
        vocab_size: int,
        hidden_size: int,
        initializer_range: Optional[float] = ...,
        **kwargs
    ) -> None: ...
    def build(self, input_shape): ...
    def get_config(self): ...
    def call(self, inputs: tf.Tensor, mode: str = ...) -> tf.Tensor: ...

class TFSequenceSummary(tf.keras.layers.Layer):
    def __init__(
        self, config: PretrainedConfig, initializer_range: float = ..., **kwargs
    ) -> None: ...
    def call(self, inputs, cls_index=..., training=...): ...

def shape_list(tensor: tf.Tensor) -> List[int]: ...
def get_initializer(
    initializer_range: float = ...,
) -> tf.initializers.TruncatedNormal: ...

class TFWrappedEmbeddings:
    def __init__(self, layer, abs_scope_name=...) -> None: ...
    def call(self, inputs, mode=...): ...
    def __call__(self, inputs, mode=...): ...
