from typing import TYPE_CHECKING, Any, Callable
import numpy as np
from pandas import Float64Index
from pandas._typing import ArrayLike, DtypeObj, Hashable
from pandas.core.arrays import ExtensionArray
from pandas.core.indexes.api import Index
from pandas.core.internals.base import DataManager, SingleDataManager

if TYPE_CHECKING: ...
T = ...

class BaseArrayManager(DataManager):
    __slots__ = ...
    arrays: list[np.ndarray | ExtensionArray]
    _axes: list[Index]
    def __init__(
        self,
        arrays: list[np.ndarray | ExtensionArray],
        axes: list[Index],
        verify_integrity: bool = ...,
    ) -> None: ...
    def make_empty(self: T, axes=...) -> T: ...
    @property
    def items(self) -> Index: ...
    @property
    def axes(self) -> list[Index]: ...
    @property
    def shape_proper(self) -> tuple[int, ...]: ...
    def set_axis(self, axis: int, new_labels: Index) -> None: ...
    def consolidate(self: T) -> T: ...
    def is_consolidated(self) -> bool: ...
    def get_dtypes(self): ...
    def __repr__(self) -> str: ...
    def apply(
        self: T,
        f,
        align_keys: list[str] | None = ...,
        ignore_failures: bool = ...,
        **kwargs
    ) -> T: ...
    def apply_with_block(self: T, f, align_keys=..., swap_axis=..., **kwargs) -> T: ...
    def where(self: T, other, cond, align: bool, errors: str) -> T: ...
    def putmask(self, mask, new, align: bool = ...): ...
    def diff(self: T, n: int, axis: int) -> T: ...
    def interpolate(self: T, **kwargs) -> T: ...
    def shift(self: T, periods: int, axis: int, fill_value) -> T: ...
    def fillna(self: T, value, limit, inplace: bool, downcast) -> T: ...
    def downcast(self: T) -> T: ...
    def astype(self: T, dtype, copy: bool = ..., errors: str = ...) -> T: ...
    def convert(
        self: T,
        copy: bool = ...,
        datetime: bool = ...,
        numeric: bool = ...,
        timedelta: bool = ...,
    ) -> T: ...
    def replace(self: T, value, **kwargs) -> T: ...
    def replace_list(
        self: T,
        src_list: list[Any],
        dest_list: list[Any],
        inplace: bool = ...,
        regex: bool = ...,
    ) -> T: ...
    def to_native_types(self, **kwargs): ...
    @property
    def is_mixed_type(self) -> bool: ...
    @property
    def is_numeric_mixed_type(self) -> bool: ...
    @property
    def any_extension_types(self) -> bool: ...
    @property
    def is_view(self) -> bool: ...
    @property
    def is_single_block(self) -> bool: ...
    def get_bool_data(self: T, copy: bool = ...) -> T: ...
    def get_numeric_data(self: T, copy: bool = ...) -> T: ...
    def copy(self: T, deep=...) -> T: ...
    def reindex_indexer(
        self: T,
        new_axis,
        indexer,
        axis: int,
        fill_value=...,
        allow_dups: bool = ...,
        copy: bool = ...,
        consolidate: bool = ...,
        only_slice: bool = ...,
        use_na_proxy: bool = ...,
    ) -> T: ...
    def take(self: T, indexer, axis: int = ..., verify: bool = ...) -> T: ...

class ArrayManager(BaseArrayManager):
    ndim = ...
    def __init__(
        self,
        arrays: list[np.ndarray | ExtensionArray],
        axes: list[Index],
        verify_integrity: bool = ...,
    ) -> None: ...
    def fast_xs(self, loc: int) -> ArrayLike: ...
    def get_slice(self, slobj: slice, axis: int = ...) -> ArrayManager: ...
    def iget(self, i: int) -> SingleArrayManager: ...
    def iget_values(self, i: int) -> ArrayLike: ...
    @property
    def column_arrays(self) -> list[ArrayLike]: ...
    def iset(self, loc: int | slice | np.ndarray, value: ArrayLike): ...
    def insert(self, loc: int, item: Hashable, value: ArrayLike) -> None: ...
    def idelete(self, indexer): ...
    def grouped_reduce(self: T, func: Callable, ignore_failures: bool = ...) -> T: ...
    def reduce(
        self: T, func: Callable, ignore_failures: bool = ...
    ) -> tuple[T, np.ndarray]: ...
    def operate_blockwise(self, other: ArrayManager, array_op) -> ArrayManager: ...
    def quantile(
        self,
        *,
        qs: Float64Index,
        axis: int = ...,
        transposed: bool = ...,
        interpolation=...
    ) -> ArrayManager: ...
    def apply_2d(
        self: ArrayManager, f, ignore_failures: bool = ..., **kwargs
    ) -> ArrayManager: ...
    def unstack(self, unstacker, fill_value) -> ArrayManager: ...
    def as_array(
        self, transpose: bool = ..., dtype=..., copy: bool = ..., na_value=...
    ) -> np.ndarray: ...

class SingleArrayManager(BaseArrayManager, SingleDataManager):
    __slots__ = ...
    arrays: list[np.ndarray | ExtensionArray]
    _axes: list[Index]
    ndim = ...
    def __init__(
        self,
        arrays: list[np.ndarray | ExtensionArray],
        axes: list[Index],
        verify_integrity: bool = ...,
    ) -> None: ...
    def make_empty(self, axes=...) -> SingleArrayManager: ...
    @classmethod
    def from_array(cls, array, index): ...
    @property
    def axes(self): ...
    @property
    def index(self) -> Index: ...
    @property
    def dtype(self): ...
    def external_values(self): ...
    def internal_values(self): ...
    def array_values(self): ...
    @property
    def is_single_block(self) -> bool: ...
    def fast_xs(self, loc: int) -> ArrayLike: ...
    def get_slice(self, slobj: slice, axis: int = ...) -> SingleArrayManager: ...
    def getitem_mgr(self, indexer) -> SingleArrayManager: ...
    def apply(self, func, **kwargs): ...
    def setitem(self, indexer, value): ...
    def idelete(self, indexer) -> SingleArrayManager: ...
    def set_values(self, values: ArrayLike): ...

class NullArrayProxy:
    ndim = ...
    def __init__(self, n: int) -> None: ...
    @property
    def shape(self): ...
    def to_array(self, dtype: DtypeObj) -> ArrayLike: ...
