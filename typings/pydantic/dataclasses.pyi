"""
This type stub file was generated by pyright.
"""

from typing import TYPE_CHECKING, Any, Callable, Optional, Type, Union, overload

from .main import BaseConfig, BaseModel
from .typing import CallableGenerator
from .utils import ClassAttribute

if TYPE_CHECKING:
    DataclassT = ...
    class Dataclass:
        __pydantic_model__: Type[BaseModel]
        __initialised__: bool
        __post_init_original__: Optional[Callable[..., None]]
        __processed__: Optional[ClassAttribute]
        __has_field_info_default__: bool
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @classmethod
        def __get_validators__(cls: Type[Dataclass]) -> CallableGenerator: ...
        @classmethod
        def __validate__(cls: Type[DataclassT], v: Any) -> DataclassT: ...
        def __call__(self: DataclassT, *args: Any, **kwargs: Any) -> DataclassT: ...

def setattr_validate_assignment(self: Dataclass, name: str, value: Any) -> None: ...
def is_builtin_dataclass(_cls: Type[Any]) -> bool:
    """
    `dataclasses.is_dataclass` is True if one of the class parents is a `dataclass`.
    This is why we also add a class attribute `__processed__` to only consider 'direct' built-in dataclasses
    """
    ...

@overload
def dataclass(
    *,
    init: bool = ...,
    repr: bool = ...,
    eq: bool = ...,
    order: bool = ...,
    unsafe_hash: bool = ...,
    frozen: bool = ...,
    config: Type[Any] = ...
) -> Callable[[Type[Any]], Type[Dataclass]]: ...
@overload
def dataclass(
    _cls: Type[Any],
    *,
    init: bool = ...,
    repr: bool = ...,
    eq: bool = ...,
    order: bool = ...,
    unsafe_hash: bool = ...,
    frozen: bool = ...,
    config: Type[Any] = ...
) -> Type[Dataclass]: ...
def dataclass(
    _cls: Optional[Type[Any]] = ...,
    *,
    init: bool = ...,
    repr: bool = ...,
    eq: bool = ...,
    order: bool = ...,
    unsafe_hash: bool = ...,
    frozen: bool = ...,
    config: Type[Any] = ...
) -> Union[Callable[[Type[Any]], Type[Dataclass]], Type[Dataclass]]:
    """
    Like the python standard lib dataclasses but with type validation.

    Arguments are the same as for standard dataclasses, except for validate_assignment which has the same meaning
    as Config.validate_assignment.
    """
    ...

def make_dataclass_validator(
    _cls: Type[Any], config: Type[BaseConfig]
) -> CallableGenerator:
    """
    Create a pydantic.dataclass from a builtin dataclass to add type validation
    and yield the validators
    It retrieves the parameters of the dataclass and forwards them to the newly created dataclass
    """
    ...
