from typing import TYPE_CHECKING, Any, Sized, overload
import numpy as np
from pandas._typing import ArrayLike, Dtype, DtypeObj, Scalar
from pandas.core.arrays import (
    DatetimeArray,
    ExtensionArray,
    IntervalArray,
    PeriodArray,
    TimedeltaArray,
)
from pandas.core.dtypes.dtypes import ExtensionDtype

if TYPE_CHECKING: ...
_int8_max = np.iinfo(np.int8).max
_int16_max = np.iinfo(np.int16).max
_int32_max = np.iinfo(np.int32).max
_int64_max = np.iinfo(np.int64).max
NumpyArrayT = ...

def maybe_convert_platform(
    values: list | tuple | range | np.ndarray | ExtensionArray,
) -> ArrayLike: ...
def is_nested_object(obj) -> bool: ...
def maybe_box_datetimelike(value: Scalar, dtype: Dtype | None = ...) -> Scalar: ...
def maybe_box_native(value: Scalar) -> Scalar: ...
def maybe_unbox_datetimelike(value: Scalar, dtype: DtypeObj) -> Scalar: ...
def maybe_downcast_to_dtype(result: ArrayLike, dtype: str | np.dtype) -> ArrayLike: ...
def maybe_downcast_numeric(
    result: ArrayLike, dtype: DtypeObj, do_round: bool = ...
) -> ArrayLike: ...
def maybe_cast_pointwise_result(
    result: ArrayLike, dtype: DtypeObj, numeric_only: bool = ..., same_dtype: bool = ...
) -> ArrayLike: ...
def maybe_cast_to_extension_array(
    cls: type[ExtensionArray], obj: ArrayLike, dtype: ExtensionDtype | None = ...
) -> ArrayLike: ...
@overload
def ensure_dtype_can_hold_na(dtype: np.dtype) -> np.dtype: ...
@overload
def ensure_dtype_can_hold_na(dtype: ExtensionDtype) -> ExtensionDtype: ...
def ensure_dtype_can_hold_na(dtype: DtypeObj) -> DtypeObj: ...
def maybe_promote(dtype: np.dtype, fill_value=...): ...
def infer_dtype_from(val, pandas_dtype: bool = ...) -> tuple[DtypeObj, Any]: ...
def infer_dtype_from_scalar(val, pandas_dtype: bool = ...) -> tuple[DtypeObj, Any]: ...
def dict_compat(d: dict[Scalar, Scalar]) -> dict[Scalar, Scalar]: ...
def infer_dtype_from_array(
    arr, pandas_dtype: bool = ...
) -> tuple[DtypeObj, ArrayLike]: ...
def maybe_infer_dtype_type(element): ...
def maybe_upcast(
    values: NumpyArrayT, fill_value: Scalar = ..., copy: bool = ...
) -> tuple[NumpyArrayT, Scalar]: ...
def invalidate_string_dtypes(dtype_set: set[DtypeObj]): ...
def coerce_indexer_dtype(indexer, categories): ...
def astype_dt64_to_dt64tz(
    values: ArrayLike, dtype: DtypeObj, copy: bool, via_utc: bool = ...
) -> DatetimeArray: ...
def astype_td64_unit_conversion(
    values: np.ndarray, dtype: np.dtype, copy: bool
) -> np.ndarray: ...
@overload
def astype_nansafe(
    arr: np.ndarray, dtype: np.dtype, copy: bool = ..., skipna: bool = ...
) -> np.ndarray: ...
@overload
def astype_nansafe(
    arr: np.ndarray, dtype: ExtensionDtype, copy: bool = ..., skipna: bool = ...
) -> ExtensionArray: ...
def astype_nansafe(
    arr: np.ndarray, dtype: DtypeObj, copy: bool = ..., skipna: bool = ...
) -> ArrayLike: ...
def astype_float_to_int_nansafe(
    values: np.ndarray, dtype: np.dtype, copy: bool
) -> np.ndarray: ...
def astype_array(values: ArrayLike, dtype: DtypeObj, copy: bool = ...) -> ArrayLike: ...
def astype_array_safe(
    values: ArrayLike, dtype, copy: bool = ..., errors: str = ...
) -> ArrayLike: ...
def soft_convert_objects(
    values: np.ndarray,
    datetime: bool = ...,
    numeric: bool = ...,
    timedelta: bool = ...,
    period: bool = ...,
    copy: bool = ...,
) -> ArrayLike: ...
def convert_dtypes(
    input_array: ArrayLike,
    convert_string: bool = ...,
    convert_integer: bool = ...,
    convert_boolean: bool = ...,
    convert_floating: bool = ...,
) -> DtypeObj: ...
def maybe_infer_to_datetimelike(
    value: np.ndarray,
) -> np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray | IntervalArray: ...
def maybe_cast_to_datetime(
    value: ExtensionArray | np.ndarray | list, dtype: DtypeObj | None
) -> ExtensionArray | np.ndarray: ...
def sanitize_to_nanoseconds(values: np.ndarray, copy: bool = ...) -> np.ndarray: ...
def ensure_nanosecond_dtype(dtype: DtypeObj) -> DtypeObj: ...
def find_common_type(types: list[DtypeObj]) -> DtypeObj: ...
def construct_2d_arraylike_from_scalar(
    value: Scalar, length: int, width: int, dtype: np.dtype, copy: bool
) -> np.ndarray: ...
def construct_1d_arraylike_from_scalar(
    value: Scalar, length: int, dtype: DtypeObj | None
) -> ArrayLike: ...
def maybe_unbox_datetimelike_tz_deprecation(
    value: Scalar, dtype: DtypeObj, stacklevel: int = ...
): ...
def construct_1d_object_array_from_listlike(values: Sized) -> np.ndarray: ...
def maybe_cast_to_integer_array(
    arr: list | np.ndarray, dtype: np.dtype, copy: bool = ...
) -> np.ndarray: ...
def convert_scalar_for_putitemlike(scalar: Scalar, dtype: np.dtype) -> Scalar: ...
def validate_numeric_casting(dtype: np.dtype, value: Scalar) -> None: ...
def can_hold_element(arr: ArrayLike, element: Any) -> bool: ...
