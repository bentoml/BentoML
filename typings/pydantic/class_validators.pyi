"""
This type stub file was generated by pyright.
"""

from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Optional,
    Set,
    Tuple,
    Type,
    Union,
    overload,
)

from .fields import ModelField
from .main import BaseConfig
from .types import ModelOrDc
from .typing import AnyCallable

class Validator:
    __slots__ = ...
    def __init__(
        self,
        func: AnyCallable,
        pre: bool = ...,
        each_item: bool = ...,
        always: bool = ...,
        check_fields: bool = ...,
        skip_on_failure: bool = ...,
    ) -> None: ...

if TYPE_CHECKING:
    ValidatorCallable = Callable[
        [Optional[ModelOrDc], Any, Dict[str, Any], ModelField, Type[BaseConfig]], Any
    ]
    ValidatorsList = List[ValidatorCallable]
    ValidatorListDict = Dict[str, List[Validator]]
_FUNCS: Set[str] = ...
VALIDATOR_CONFIG_KEY = ...
ROOT_VALIDATOR_CONFIG_KEY = ...

def validator(
    *fields: str,
    pre: bool = ...,
    each_item: bool = ...,
    always: bool = ...,
    check_fields: bool = ...,
    whole: bool = ...,
    allow_reuse: bool = ...
) -> Callable[[AnyCallable], classmethod]:
    """
    Decorate methods on the class indicating that they should be used to validate fields
    :param fields: which field(s) the method should be called on
    :param pre: whether or not this validator should be called before the standard validators (else after)
    :param each_item: for complex objects (sets, lists etc.) whether to validate individual elements rather than the
      whole object
    :param always: whether this method and other validators should be called even if the value is missing
    :param check_fields: whether to check that the fields actually exist on the model
    :param allow_reuse: whether to track and raise an error if another validator refers to the decorated function
    """
    ...

@overload
def root_validator(_func: AnyCallable) -> classmethod: ...
@overload
def root_validator(
    *, pre: bool = ..., allow_reuse: bool = ..., skip_on_failure: bool = ...
) -> Callable[[AnyCallable], classmethod]: ...
def root_validator(
    _func: Optional[AnyCallable] = ...,
    *,
    pre: bool = ...,
    allow_reuse: bool = ...,
    skip_on_failure: bool = ...
) -> Union[classmethod, Callable[[AnyCallable], classmethod]]:
    """
    Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either
    before or after standard model parsing/validation is performed.
    """
    ...

class ValidatorGroup:
    def __init__(self, validators: ValidatorListDict) -> None: ...
    def get_validators(self, name: str) -> Optional[Dict[str, Validator]]: ...
    def check_for_unused(self) -> None: ...

def extract_validators(namespace: Dict[str, Any]) -> Dict[str, List[Validator]]: ...
def extract_root_validators(
    namespace: Dict[str, Any]
) -> Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]: ...
def inherit_validators(
    base_validators: ValidatorListDict, validators: ValidatorListDict
) -> ValidatorListDict: ...
def make_generic_validator(validator: AnyCallable) -> ValidatorCallable:
    """
    Make a generic function which calls a validator with the right arguments.

    Unfortunately other approaches (eg. return a partial of a function that builds the arguments) is slow,
    hence this laborious way of doing things.

    It's done like this so validators don't all need **kwargs in their signature, eg. any combination of
    the arguments "values", "fields" and/or "config" are permitted.
    """
    ...

def prep_validators(v_funcs: Iterable[AnyCallable]) -> ValidatorsList: ...

all_kwargs = ...

def gather_all_validators(type_: ModelOrDc) -> Dict[str, classmethod]: ...
