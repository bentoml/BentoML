import numpy as np
from pandas._libs.sparse import SparseIndex
from pandas._typing import Dtype, NpDtype, Scalar
from pandas.core.arraylike import OpsMixin
from pandas.core.arrays import ExtensionArray
from pandas.core.arrays.sparse.dtype import SparseDtype
from pandas.core.base import PandasObject

SparseArrayT = ...
_sparray_doc_kwargs = ...

class SparseArray(OpsMixin, PandasObject, ExtensionArray):
    _subtyp = ...
    _hidden_attrs = ...
    _sparse_index: SparseIndex
    def __init__(
        self,
        data,
        sparse_index=...,
        index=...,
        fill_value=...,
        kind=...,
        dtype: Dtype | None = ...,
        copy=...,
    ) -> None: ...
    @classmethod
    def from_spmatrix(cls, data): ...
    def __array__(self, dtype: NpDtype | None = ...) -> np.ndarray: ...
    def __setitem__(self, key, value): ...
    @property
    def sp_index(self) -> SparseIndex: ...
    @property
    def sp_values(self) -> np.ndarray: ...
    @property
    def dtype(self) -> SparseDtype: ...
    @property
    def fill_value(self): ...
    @fill_value.setter
    def fill_value(self, value): ...
    @property
    def kind(self) -> str: ...
    def __len__(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    @property
    def density(self) -> float: ...
    @property
    def npoints(self) -> int: ...
    def isna(self): ...
    def fillna(self, value=..., method=..., limit=...): ...
    def shift(self, periods=..., fill_value=...): ...
    def unique(self): ...
    def factorize(self, na_sentinel=...): ...
    def value_counts(self, dropna: bool = ...): ...
    def __getitem__(self, key): ...
    def take(self, indices, *, allow_fill=..., fill_value=...) -> SparseArray: ...
    def searchsorted(self, v, side=..., sorter=...): ...
    def copy(self: SparseArrayT) -> SparseArrayT: ...
    def astype(self, dtype: Dtype | None = ..., copy=...): ...
    def map(self, mapper): ...
    def to_dense(self): ...
    _internal_get_values = ...
    def __setstate__(self, state): ...
    def nonzero(self): ...
    def all(self, axis=..., *args, **kwargs): ...
    def any(self, axis=..., *args, **kwargs): ...
    def sum(self, axis: int = ..., min_count: int = ..., *args, **kwargs) -> Scalar: ...
    def cumsum(self, axis=..., *args, **kwargs): ...
    def mean(self, axis=..., *args, **kwargs): ...
    def max(self, axis=..., *args, **kwargs): ...
    def min(self, axis=..., *args, **kwargs): ...
    _HANDLED_TYPES = ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def __abs__(self): ...
    _logical_method = ...
    def __pos__(self) -> SparseArray: ...
    def __neg__(self) -> SparseArray: ...
    def __invert__(self) -> SparseArray: ...
    def __repr__(self) -> str: ...
