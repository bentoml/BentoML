from typing import TYPE_CHECKING, Callable, Iterable, Sequence
import numpy as np
from pandas._typing import IndexKeyFunc, Shape
from pandas.core.indexes.base import Index

if TYPE_CHECKING: ...

def get_indexer_indexer(
    target: Index,
    level: str | int | list[str] | list[int],
    ascending: Sequence[bool | int] | bool | int,
    kind: str,
    na_position: str,
    sort_remaining: bool,
    key: IndexKeyFunc,
) -> np.ndarray | None: ...
def get_group_index(labels, shape: Shape, sort: bool, xnull: bool): ...
def get_compressed_ids(labels, sizes: Shape) -> tuple[np.ndarray, np.ndarray]: ...
def is_int64_overflow_possible(shape) -> bool: ...
def decons_group_index(comp_labels, shape): ...
def decons_obs_group_ids(comp_ids: np.ndarray, obs_ids, shape, labels, xnull: bool): ...
def indexer_from_factorized(
    labels, shape: Shape, compress: bool = ...
) -> np.ndarray: ...
def lexsort_indexer(
    keys, orders=..., na_position: str = ..., key: Callable | None = ...
) -> np.ndarray: ...
def nargsort(
    items,
    kind: str = ...,
    ascending: bool = ...,
    na_position: str = ...,
    key: Callable | None = ...,
    mask: np.ndarray | None = ...,
): ...
def nargminmax(values, method: str, axis: int = ...): ...
def ensure_key_mapped(values, key: Callable | None, levels=...): ...
def get_flattened_list(
    comp_ids: np.ndarray,
    ngroups: int,
    levels: Iterable[Index],
    labels: Iterable[np.ndarray],
) -> list[tuple]: ...
def get_indexer_dict(
    label_list: list[np.ndarray], keys: list[Index]
) -> dict[str | tuple, np.ndarray]: ...
def get_group_index_sorter(
    group_index: np.ndarray, ngroups: int | None = ...
) -> np.ndarray: ...
def compress_group_index(
    group_index: np.ndarray, sort: bool = ...
) -> tuple[np.ndarray, np.ndarray]: ...
