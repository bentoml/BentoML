from typing import TYPE_CHECKING, Any, Callable, Literal, Sequence, Union, overload

import numpy as np
from pandas._libs.tslibs import NaTType
from pandas._typing import (
    ArrayLike,
    DatetimeLikeScalar,
    Dtype,
    DtypeObj,
    NpDtype,
    PositionalIndexer2D,
)
from pandas.core.arraylike import OpsMixin
from pandas.core.arrays import DatetimeArray, TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray, ravel_compat
from pandas.core.ops.common import unpack_zerodim_and_defer
from pandas.util._decorators import Appender, Substitution

if TYPE_CHECKING: ...
DTScalarOrNaT = Union[DatetimeLikeScalar, NaTType]
DatetimeLikeArrayT = ...

class InvalidComparison(Exception):
    """
    Raised by _validate_comparison_value to indicate to caller it should
    return invalid_comparison.
    """

    ...

class DatetimeLikeArrayMixin(OpsMixin, NDArrayBackedExtensionArray):
    """
    Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray

    Assumes that __new__/__init__ defines:
        _data
        _freq

    and that the inheriting class has methods:
        _generate_range
    """

    _infer_matches: tuple[str, ...]
    _is_recognized_dtype: Callable[[DtypeObj], bool]
    _recognized_scalars: tuple[type, ...]
    _ndarray: np.ndarray
    def __init__(self, data, dtype: Dtype | None = ..., freq=..., copy=...) -> None: ...
    def __iter__(self): ...
    @property
    def asi8(self) -> np.ndarray:
        """
        Integer representation of the values.

        Returns
        -------
        ndarray
            An ndarray with int64 dtype.
        """
        ...
    def __array__(self, dtype: NpDtype | None = ...) -> np.ndarray: ...
    def __getitem__(
        self, key: PositionalIndexer2D
    ) -> DatetimeLikeArrayMixin | DTScalarOrNaT:
        """
        This getitem defers to the underlying array, which by-definition can
        only handle list-likes, slices, and integer scalars
        """
        ...
    def __setitem__(
        self,
        key: int | Sequence[int] | Sequence[bool] | slice,
        value: NaTType | Any | Sequence[Any],
    ) -> None: ...
    def astype(self, dtype, copy: bool = ...): ...
    @overload
    def view(self: DatetimeLikeArrayT) -> DatetimeLikeArrayT: ...
    @overload
    def view(self, dtype: Literal["M8[ns]"]) -> DatetimeArray: ...
    @overload
    def view(self, dtype: Literal["m8[ns]"]) -> TimedeltaArray: ...
    @overload
    def view(self, dtype: Dtype | None = ...) -> ArrayLike: ...
    def view(self, dtype: Dtype | None = ...) -> ArrayLike: ...
    def copy(self: DatetimeLikeArrayT) -> DatetimeLikeArrayT: ...
    @ravel_compat
    def map(self, mapper): ...
    def isin(self, values) -> np.ndarray:
        """
        Compute boolean array of whether each value is found in the
        passed set of values.

        Parameters
        ----------
        values : set or sequence of values

        Returns
        -------
        ndarray[bool]
        """
        ...
    def isna(self) -> np.ndarray: ...
    @property
    def freq(self):
        """
        Return the frequency object if it is set, otherwise None.
        """
        ...
    @freq.setter
    def freq(self, value): ...
    @property
    def freqstr(self) -> str | None:
        """
        Return the frequency object as a string if its set, otherwise None.
        """
        ...
    @property
    def inferred_freq(self) -> str | None:
        """
        Tries to return a string representing a frequency guess,
        generated by infer_freq.  Returns None if it can't autodetect the
        frequency.
        """
        ...
    @property
    def resolution(self) -> str:
        """
        Returns day, hour, minute, second, millisecond or microsecond
        """
        ...
    __pow__ = ...
    __rpow__ = ...
    __mul__ = ...
    __rmul__ = ...
    __truediv__ = ...
    __rtruediv__ = ...
    __floordiv__ = ...
    __rfloordiv__ = ...
    __mod__ = ...
    __rmod__ = ...
    __divmod__ = ...
    __rdivmod__ = ...
    _add_datetime_arraylike = ...
    _sub_datetime_arraylike = ...
    @unpack_zerodim_and_defer("__add__")
    def __add__(self, other): ...
    def __radd__(self, other): ...
    @unpack_zerodim_and_defer("__sub__")
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def min(self, *, axis: int | None = ..., skipna: bool = ..., **kwargs):  # -> NaTType:
        """
        Return the minimum value of the Array or minimum along
        an axis.

        See Also
        --------
        numpy.ndarray.min
        Index.min : Return the minimum value in an Index.
        Series.min : Return the minimum value in a Series.
        """
        ...
    def max(
        self, *, axis: int | None = ..., skipna: bool = ..., **kwargs
    ):  # -> Dtype | Type[str]:
        """
        Return the maximum value of the Array or maximum along
        an axis.

        See Also
        --------
        numpy.ndarray.max
        Index.max : Return the maximum value in an Index.
        Series.max : Return the maximum value in a Series.
        """
        ...
    def mean(self, *, skipna: bool = ..., axis: int | None = ...):
        """
        Return the mean value of the Array.

        .. versionadded:: 0.25.0

        Parameters
        ----------
        skipna : bool, default True
            Whether to ignore any NaT elements.
        axis : int, optional, default 0

        Returns
        -------
        scalar
            Timestamp or Timedelta.

        See Also
        --------
        numpy.ndarray.mean : Returns the average of array elements along a given axis.
        Series.mean : Return the mean value in a Series.

        Notes
        -----
        mean is only defined for Datetime and Timedelta dtypes, not for Period.
        """
        ...
    def median(self, *, axis: int | None = ..., skipna: bool = ..., **kwargs): ...

class DatelikeOps(DatetimeLikeArrayMixin):
    """
    Common ops for DatetimeIndex/PeriodIndex, but not TimedeltaIndex.
    """

    @Substitution(
        URL="https://docs.python.org/3/library/datetime.html"
        "#strftime-and-strptime-behavior"
    )
    def strftime(self, date_format: str) -> np.ndarray:
        """
        Convert to Index using specified date_format.

        Return an Index of formatted strings specified by date_format, which
        supports the same string format as the python standard library. Details
        of the string format can be found in `python string format
        doc <%(URL)s>`__.

        Parameters
        ----------
        date_format : str
            Date format string (e.g. "%%Y-%%m-%%d").

        Returns
        -------
        ndarray
            NumPy ndarray of formatted strings.

        See Also
        --------
        to_datetime : Convert the given argument to datetime.
        DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.
        DatetimeIndex.round : Round the DatetimeIndex to the specified freq.
        DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.

        Examples
        --------
        >>> rng = pd.date_range(pd.Timestamp("2018-03-10 09:00"),
        ...                     periods=3, freq='s')
        >>> rng.strftime('%%B %%d, %%Y, %%r')
        Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',
               'March 10, 2018, 09:00:02 AM'],
              dtype='object')
        """
        ...

_round_doc = ...
_round_example = ...
_floor_example = ...
_ceil_example = ...
TimelikeOpsT = ...

class TimelikeOps(DatetimeLikeArrayMixin):
    """
    Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.
    """

    @Appender((_round_doc + _round_example).format(op="round"))
    def round(self, freq, ambiguous=..., nonexistent=...): ...
    @Appender((_round_doc + _floor_example).format(op="floor"))
    def floor(self, freq, ambiguous=..., nonexistent=...): ...
    @Appender((_round_doc + _ceil_example).format(op="ceil"))
    def ceil(self, freq, ambiguous=..., nonexistent=...): ...
    def any(self, *, axis: int | None = ..., skipna: bool = ...): ...
    def all(self, *, axis: int | None = ..., skipna: bool = ...): ...
    def factorize(self, na_sentinel=..., sort: bool = ...): ...

def validate_periods(periods):  # -> int:
    """
    If a `periods` argument is passed to the Datetime/Timedelta Array/Index
    constructor, cast it to an integer.

    Parameters
    ----------
    periods : None, float, int

    Returns
    -------
    periods : None or int

    Raises
    ------
    TypeError
        if periods is None, float, or int
    """
    ...

def validate_endpoints(closed):  # -> tuple[bool, bool]:
    """
    Check that the `closed` argument is among [None, "left", "right"]

    Parameters
    ----------
    closed : {None, "left", "right"}

    Returns
    -------
    left_closed : bool
    right_closed : bool

    Raises
    ------
    ValueError : if argument is not among valid values
    """
    ...

def validate_inferred_freq(
    freq, inferred_freq, freq_infer
):  # -> tuple[Unknown, Unknown | Literal[False]]:
    """
    If the user passes a freq and another freq is inferred from passed data,
    require that they match.

    Parameters
    ----------
    freq : DateOffset or None
    inferred_freq : DateOffset or None
    freq_infer : bool

    Returns
    -------
    freq : DateOffset or None
    freq_infer : bool

    Notes
    -----
    We assume at this point that `maybe_infer_freq` has been called, so
    `freq` is either a DateOffset object or None.
    """
    ...

def maybe_infer_freq(freq):  # -> tuple[Unknown | None, bool]:
    """
    Comparing a DateOffset to the string "infer" raises, so we need to
    be careful about comparisons.  Make a dummy variable `freq_infer` to
    signify the case where the given freq is "infer" and set freq to None
    to avoid comparison trouble later on.

    Parameters
    ----------
    freq : {DateOffset, None, str}

    Returns
    -------
    freq : {DateOffset, None}
    freq_infer : bool
        Whether we should inherit the freq of passed data.
    """
    ...
