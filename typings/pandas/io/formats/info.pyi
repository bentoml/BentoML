from abc import ABC, abstractmethod
from typing import IO, TYPE_CHECKING, Iterable, Mapping, Sequence
from pandas._typing import Dtype, FrameOrSeriesUnion
from pandas.core.frame import DataFrame
from pandas.core.indexes.api import Index

if TYPE_CHECKING: ...

class BaseInfo(ABC):
    data: FrameOrSeriesUnion
    memory_usage: bool | str
    @property
    @abstractmethod
    def dtypes(self) -> Iterable[Dtype]: ...
    @property
    @abstractmethod
    def dtype_counts(self) -> Mapping[str, int]: ...
    @property
    @abstractmethod
    def non_null_counts(self) -> Sequence[int]: ...
    @property
    @abstractmethod
    def memory_usage_bytes(self) -> int: ...
    @property
    def memory_usage_string(self) -> str: ...
    @property
    def size_qualifier(self) -> str: ...
    @abstractmethod
    def render(
        self,
        *,
        buf: IO[str] | None,
        max_cols: int | None,
        verbose: bool | None,
        show_counts: bool | None
    ) -> None: ...

class DataFrameInfo(BaseInfo):
    def __init__(
        self, data: DataFrame, memory_usage: bool | str | None = ...
    ) -> None: ...
    @property
    def dtype_counts(self) -> Mapping[str, int]: ...
    @property
    def dtypes(self) -> Iterable[Dtype]: ...
    @property
    def ids(self) -> Index: ...
    @property
    def col_count(self) -> int: ...
    @property
    def non_null_counts(self) -> Sequence[int]: ...
    @property
    def memory_usage_bytes(self) -> int: ...
    def render(
        self,
        *,
        buf: IO[str] | None,
        max_cols: int | None,
        verbose: bool | None,
        show_counts: bool | None
    ) -> None: ...

class InfoPrinterAbstract:
    def to_buffer(self, buf: IO[str] | None = ...) -> None: ...

class DataFrameInfoPrinter(InfoPrinterAbstract):
    def __init__(
        self,
        info: DataFrameInfo,
        max_cols: int | None = ...,
        verbose: bool | None = ...,
        show_counts: bool | None = ...,
    ) -> None: ...
    @property
    def max_rows(self) -> int: ...
    @property
    def exceeds_info_cols(self) -> bool: ...
    @property
    def exceeds_info_rows(self) -> bool: ...
    @property
    def col_count(self) -> int: ...

class TableBuilderAbstract(ABC):
    _lines: list[str]
    info: BaseInfo
    @abstractmethod
    def get_lines(self) -> list[str]: ...
    @property
    def data(self) -> FrameOrSeriesUnion: ...
    @property
    def dtypes(self) -> Iterable[Dtype]: ...
    @property
    def dtype_counts(self) -> Mapping[str, int]: ...
    @property
    def display_memory_usage(self) -> bool: ...
    @property
    def memory_usage_string(self) -> str: ...
    @property
    def non_null_counts(self) -> Sequence[int]: ...
    def add_object_type_line(self) -> None: ...
    def add_index_range_line(self) -> None: ...
    def add_dtypes_line(self) -> None: ...

class DataFrameTableBuilder(TableBuilderAbstract):
    def __init__(self, *, info: DataFrameInfo) -> None: ...
    def get_lines(self) -> list[str]: ...
    @property
    def data(self) -> DataFrame: ...
    @property
    def ids(self) -> Index: ...
    @property
    def col_count(self) -> int: ...
    def add_memory_usage_line(self) -> None: ...

class DataFrameTableBuilderNonVerbose(DataFrameTableBuilder):
    def add_columns_summary_line(self) -> None: ...

class TableBuilderVerboseMixin(TableBuilderAbstract):
    SPACING: str = ...
    strrows: Sequence[Sequence[str]]
    gross_column_widths: Sequence[int]
    with_counts: bool
    @property
    @abstractmethod
    def headers(self) -> Sequence[str]: ...
    @property
    def header_column_widths(self) -> Sequence[int]: ...
    def add_header_line(self) -> None: ...
    def add_separator_line(self) -> None: ...
    def add_body_lines(self) -> None: ...

class DataFrameTableBuilderVerbose(DataFrameTableBuilder, TableBuilderVerboseMixin):
    def __init__(self, *, info: DataFrameInfo, with_counts: bool) -> None: ...
    @property
    def headers(self) -> Sequence[str]: ...
    def add_columns_summary_line(self) -> None: ...
