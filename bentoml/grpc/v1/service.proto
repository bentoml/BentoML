syntax = "proto3";

package bentoml.grpc.v1;

import "google/protobuf/struct.proto";

// cc_enable_arenas pre-allocate memory for given message to improve speed. (C++ only)
option cc_enable_arenas = true;
option cc_generic_services = true;
option go_package = "github.com/bentoml/grpc/v1";
option java_multiple_files = true;
option java_outer_classname = "ServiceProto";
option java_package = "com.bentoml.grpc.v1";
option objc_class_prefix = "SVC";
option py_generic_services = true;

// a gRPC BentoServer.
service BentoService {
  // Infer handles unary API.
  rpc Infer(Request) returns (Response) {}
}

// Request for Infer.
message Request {
  // a given API route the rpc request is sent to.
  string api_name = 1;

  Value contents = 2;

// TODO:
// The data contained in an input can be represented in
// "raw" bytes form or in the repeated type that matches the data type.
// Using the "raw" bytes form will typically allow higher performance due to the way protobuf
// allocation and reuse interacts with GRPC.
// For example, see https://github.com/grpc/grpc/issues/23231.
// bytes raw_bytes_contents = 3;
}

// Response from Infer.
message Response {
  // representation of the output value.
  Value contents = 1;

// TODO:
// The data contained in an input can be represented in
// "raw" bytes form or in the repeated type that matches the data type.
// Using the "raw" bytes form will typically allow higher performance due to the way protobuf
// allocation and reuse interacts with GRPC.
// For example, see https://github.com/grpc/grpc/issues/23231.
// bytes raw_bytes_contents = 2;
}

// Represents a n-dimensional array.
// This is synonymous to NumpyNdarray IO Descriptor.
message NDArray {
  // The shape of the array.
  repeated int32 shape = 1;
  // The contents of the array as flattened.
  optional Array array = 2;
}

// This represents a 1-d array.
message Array {
  optional DataType dtype = 1;

  // Type specific representations that make it easy to create protos in
  // all languages. The values hold the flattened representation of the inputs in row major order.

  // Serialized bytes contents.
  // The purpose of this representation is to
  // reduce serialization overhead during RPC call by avoiding serialization of
  // many repeated small items.
  // for quantized types, use bytes_contents
  bytes bytes_contents = 2;

  // DT_BOOL
  repeated bool bool_contents = 7 [packed = true];

  // DT_FLOAT, DT_COMPLEX64
  // Note that since protobuf has no int16 type, we'll have some pointless zero padding for each value here.
  repeated float float_contents = 3 [packed = true];

  // DT_STRING
  repeated string string_contents = 6;

  // DT_DOUBLE, DT_COMPLEX128
  repeated double double_contents = 4 [packed = true];

  // DT_INT32, DT_INT16, DT_UINT16, DT_INT8, DT_UINT8, DT_HALF, DT_BFLOAT16
  repeated int32 int_contents = 5 [packed = true];

  // DT_INT64
  repeated int64 long_contents = 8 [packed = true];

  // DT_UINT32
  repeated uint32 uint32_val = 11 [packed = true];

  // DT_UINT64
  repeated uint64 uint64_val = 12 [packed = true];

  // TODO: support single/double precision complex value type.

  // User can specify arbitrary struct that then can be parsed to numpy.
  // DT_STRUCT
  repeated google.protobuf.Struct struct_contents = 10;

  reserved 13, 14, 15;
}

// Represents file types.
// This is synonymous to File IO Descriptor.
message File {
  // type of file, let it be csv, text ,parquet,  etc.
  optional string kind = 1;
  // contents of file as bytes.
  bytes content = 2;
}

// Represents a map value.
// This can be used for PandasDataFrame IO Descriptor.
message MapValue {
  map<string, Value> fields = 1;
}

// Representing contents of a given rpc call.
message Value {
  oneof kind {
    // Text()
    string string_value = 1;
    // File(), Image()
    File file_value = 2;
    // NDArray(), etc.
    Array array_value = 3;
    // NDArray(), etc.
    NDArray ndarray_value = 4;
    // DataFrame()
    MapValue map_value = 5;
  }
  // We want to reserve these for future uses.
  reserved 56 to 100;
}

// Represents data type that can be passed to numpy.
enum DataType {
  // Not a legal value for DataType.  Used to indicate a DataType field
  // has not been set.
  DT_UNSPECIFIED = 0;

  // Data types that all computation devices are expected to be
  // capable to support.
  DT_FLOAT = 1;
  DT_DOUBLE = 2;

  // int type
  DT_INT64 = 9;
  DT_INT32 = 3;
  DT_INT16 = 5;
  DT_INT8 = 6;

  // string type
  DT_STRING = 7;

  // bool type
  DT_BOOL = 10;

  // Represents half data type (32 -> 16 bits).
  DT_HALF = 19;
  // Float32 truncated to 16 bits.  Only for cast ops.
  DT_BFLOAT16 = 14;

  // Quantized int8
  DT_QINT8 = 11;
  // Quantized uint8
  DT_QUINT8 = 12;
  // Quantized int32
  DT_QINT32 = 13;
  // Quantized int16
  DT_QINT16 = 15;
  // Quantized uint16
  DT_QUINT16 = 16;

  // Double-precision complex
  DT_COMPLEX128 = 18;
  // Single-precision complex
  DT_COMPLEX64 = 8;

  // unsigned int type
  DT_UINT64 = 21;
  DT_UINT32 = 20;
  DT_UINT16 = 17;
  DT_UINT8 = 4;

  // struct dtype
  DT_STRUCT = 22;
}
