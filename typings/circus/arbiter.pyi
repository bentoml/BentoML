"""
This type stub file was generated by pyright.
"""

from circus.fixed_threading import Thread
from tornado import gen
from circus.util import debuglog, synchronized

_ENV_EXCEPTIONS = ...
class Arbiter:
    """Class used to control a list of watchers.

    Options:

    - **watchers** -- a list of Watcher objects
    - **endpoint** -- the controller ZMQ endpoint
    - **pubsub_endpoint** -- the pubsub endpoint
    - **statsd** -- If True, a circusd-stats process is run (default: False)
    - **stats_endpoint** -- the stats endpoint.
    - **statsd_close_outputs** -- if True sends the circusd-stats stdout/stderr
      to /dev/null (default: False)
    - **multicast_endpoint** -- the multicast endpoint for circusd cluster
      auto-discovery (default: udp://237.219.251.97:12027)
      Multicast addr should be between 224.0.0.0 to 239.255.255.255 and the
      same for the all cluster.
    - **check_delay** -- the delay between two controller points
      (default: 1 s)
    - **prereload_fn** -- callable that will be executed on each reload
      (default: None)
    - **context** -- if provided, the zmq context to reuse.
      (default: None)
    - **loop**: if provided, a :class:`zmq.eventloop.ioloop.IOLoop` instance
       to reuse. (default: None)
    - **plugins** -- a list of plugins. Each item is a mapping with:

        - **use** -- Fully qualified name that points to the plugin class
        - every other value is passed to the plugin in the **config** option
    - **sockets** -- a mapping of sockets. Each key is the socket name,
      and each value a :class:`CircusSocket` class. (default: None)
    - **warmup_delay** -- a delay in seconds between two watchers startup.
      (default: 0)
    - **httpd** -- If True, a circushttpd process is run (default: False)
    - **httpd_host** -- the circushttpd host (default: localhost)
    - **httpd_port** -- the circushttpd port (default: 8080)
    - **httpd_close_outputs** -- if True, sends circushttpd stdout/stderr
      to /dev/null. (default: False)
    - **debug** -- if True, adds a lot of debug info in the stdout (default:
      False)
    - **debug_gc** -- if True, does gc.set_debug(gc.DEBUG_LEAK) (default:
      False)
      to circusd to analyze problems (default: False)
    - **proc_name** -- the arbiter process name
    - **fqdn_prefix** -- a prefix for the unique identifier of the circus
                         instance on the cluster.
    - **endpoint_owner** -- unix user to chown the endpoint to if using ipc.
    - **papa_endpoint** -- the papa process kernel endpoint
    """
    def __init__(self, watchers, endpoint, pubsub_endpoint, check_delay=..., prereload_fn=..., context=..., loop=..., statsd=..., stats_endpoint=..., statsd_close_outputs=..., multicast_endpoint=..., plugins=..., sockets=..., warmup_delay=..., httpd=..., httpd_host=..., httpd_port=..., httpd_close_outputs=..., debug=..., debug_gc=..., ssh_server=..., proc_name=..., pidfile=..., loglevel=..., logoutput=..., loggerconfig=..., fqdn_prefix=..., umask=..., endpoint_owner=..., papa_endpoint=...) -> None:
        ...
    
    @property
    def running(self): # -> bool:
        ...
    
    def get_socket(self, name): # -> None:
        ...
    
    def get_watcher_config(self, config, name): # -> None:
        ...
    
    def get_plugin_config(self, config, name): # -> None:
        ...
    
    @classmethod
    def get_arbiter_config(cls, config):
        ...
    
    @synchronized("arbiter_reload_config")
    @gen.coroutine
    def reload_from_config(self, config_file=..., inside_circusd=...):
        ...
    
    @classmethod
    def load_from_config(cls, config_file, loop=...): # -> Self@Arbiter:
        ...
    
    def iter_watchers(self, reverse=...): # -> list[_T@sorted]:
        ...
    
    @debuglog
    def initialize(self): # -> None:
        ...
    
    @gen.coroutine
    def start_watcher(self, watcher): # -> Generator[Unknown | Future, None, None]:
        """Aska a specific watcher to start and wait for the specified
        warmup delay."""
        ...
    
    @gen.coroutine
    @debuglog
    def start(self, cb=...): # -> Generator[Future, None, None]:
        """Starts all the watchers.

        If the ioloop has been provided during __init__() call,
        starts all watchers as a standard coroutine

        If the ioloop hasn't been provided during __init__() call (default),
        starts all watchers and the eventloop (and blocks here). In this mode
        the method MUST NOT yield anything because it's called as a standard
        method.

        :param cb: Callback called after all the watchers have been started,
                   when the loop hasn't been provided.
        :type function:
        """
        ...
    
    def stop_controller_and_close_sockets(self): # -> None:
        ...
    
    def start_io_loop(self): # -> None:
        """Starts the ioloop and wait inside it
        """
        ...
    
    @synchronized("arbiter_stop")
    @gen.coroutine
    def stop(self, for_shutdown=...): # -> Generator[Future, None, None]:
        ...
    
    def reap_processes(self): # -> None:
        ...
    
    @synchronized("manage_watchers")
    @gen.coroutine
    def manage_watchers(self): # -> Generator[list[Unknown], None, None]:
        ...
    
    @synchronized("arbiter_reload")
    @gen.coroutine
    @debuglog
    def reload(self, graceful=..., sequential=...): # -> Generator[Unknown, None, None]:
        """Reloads everything.

        Run the :func:`prereload_fn` callable if any, then gracefuly
        reload all watchers.
        """
        ...
    
    def numprocesses(self): # -> int:
        """Return the number of processes running across all watchers."""
        ...
    
    def numwatchers(self): # -> int:
        """Return the number of watchers."""
        ...
    
    def get_watcher(self, name):
        """Return the watcher *name*."""
        ...
    
    def statuses(self): # -> dict[Unknown, Unknown]:
        ...
    
    @synchronized("arbiter_add_watcher")
    def add_watcher(self, name, cmd, **kw): # -> ValueError | Watcher:
        """Adds a watcher.

        Options:

        - **name**: name of the watcher to add
        - **cmd**: command to run.
        - all other options defined in the Watcher constructor.
        """
        ...
    
    @synchronized("arbiter_rm_watcher")
    @gen.coroutine
    def rm_watcher(self, name, nostop=...): # -> Generator[Unknown, None, None]:
        """Deletes a watcher.

        Options:

        - **name**: name of the watcher to delete
        """
        ...
    
    @synchronized("arbiter_start_watchers")
    @gen.coroutine
    def start_watchers(self, watcher_iter_func=...): # -> Generator[Future, None, None]:
        ...
    
    @synchronized("arbiter_stop_watchers")
    @gen.coroutine
    def stop_watchers(self, watcher_iter_func=...): # -> Generator[Future, None, None]:
        ...
    
    @synchronized("arbiter_restart")
    @gen.coroutine
    def restart(self, inside_circusd=..., watcher_iter_func=...): # -> Generator[Future, None, None]:
        ...
    
    @property
    def endpoint_owner_mode(self): # -> Literal[False]:
        ...
    


class ThreadedArbiter(Thread, Arbiter):
    def __init__(self, *args, **kw) -> None:
        ...
    
    def start(self): # -> None:
        ...
    
    def run(self): # -> Future:
        ...
    
    def stop(self): # -> None:
        ...
    


