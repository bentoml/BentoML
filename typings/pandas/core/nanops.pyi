from typing import Any
import numpy as np
from pandas._typing import ArrayLike, F
from pandas.core.dtypes.dtypes import PeriodDtype

bn = ...
_BOTTLENECK_INSTALLED = ...
_USE_BOTTLENECK = ...

def set_use_bottleneck(v: bool = ...) -> None: ...

class disallow:
    def __init__(self, *dtypes) -> None: ...
    def check(self, obj) -> bool: ...
    def __call__(self, f: F) -> F: ...

class bottleneck_switch:
    def __init__(self, name=..., **kwargs) -> None: ...
    def __call__(self, alt: F) -> F: ...

def nanany(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> bool: ...
def nanall(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> bool: ...
@disallow("M8")
@_datetimelike_compat
def nansum(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    min_count: int = ...,
    mask: np.ndarray | None = ...
) -> float: ...
@disallow(PeriodDtype)
@bottleneck_switch()
@_datetimelike_compat
def nanmean(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> float: ...
@bottleneck_switch()
def nanmedian(values, *, axis=..., skipna=..., mask=...): ...
def get_empty_reduction_result(
    shape: tuple[int, ...],
    axis: int,
    dtype: np.dtype | type[np.floating],
    fill_value: Any,
) -> np.ndarray: ...
@bottleneck_switch(ddof=1)
def nanstd(values, *, axis=..., skipna=..., ddof=..., mask=...): ...
@disallow("M8", "m8")
@bottleneck_switch(ddof=1)
def nanvar(values, *, axis=..., skipna=..., ddof=..., mask=...): ...
@disallow("M8", "m8")
def nansem(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    ddof: int = ...,
    mask: np.ndarray | None = ...
) -> float: ...

nanmin = ...
nanmax = ...

@disallow("O")
def nanargmax(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> int | np.ndarray: ...
@disallow("O")
def nanargmin(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> int | np.ndarray: ...
@disallow("M8", "m8")
def nanskew(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> float: ...
@disallow("M8", "m8")
def nankurt(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    mask: np.ndarray | None = ...
) -> float: ...
@disallow("M8", "m8")
def nanprod(
    values: np.ndarray,
    *,
    axis: int | None = ...,
    skipna: bool = ...,
    min_count: int = ...,
    mask: np.ndarray | None = ...
) -> float: ...
def check_below_min_count(
    shape: tuple[int, ...], mask: np.ndarray | None, min_count: int
) -> bool: ...
@disallow("M8", "m8")
def nancorr(
    a: np.ndarray, b: np.ndarray, *, method=..., min_periods: int | None = ...
): ...
def get_corr_func(method): ...
@disallow("M8", "m8")
def nancov(
    a: np.ndarray,
    b: np.ndarray,
    *,
    min_periods: int | None = ...,
    ddof: int | None = ...
): ...
def make_nancomp(op): ...

nangt = ...
nange = ...
nanlt = ...
nanle = ...
naneq = ...
nanne = ...

def nanpercentile(
    values: np.ndarray, q: np.ndarray, *, na_value, mask: np.ndarray, interpolation
): ...
def na_accum_func(values: ArrayLike, accum_func, *, skipna: bool) -> ArrayLike: ...
