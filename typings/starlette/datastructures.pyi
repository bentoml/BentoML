"""
This type stub file was generated by pyright.
"""

import typing
from collections.abc import Sequence
from urllib.parse import SplitResult
from starlette.types import Scope

Address = ...

class URL:
    def __init__(
        self, url: str = ..., scope: Scope = ..., **components: typing.Any
    ) -> None: ...
    @property
    def components(self) -> SplitResult: ...
    @property
    def scheme(self) -> str: ...
    @property
    def netloc(self) -> str: ...
    @property
    def path(self) -> str: ...
    @property
    def query(self) -> str: ...
    @property
    def fragment(self) -> str: ...
    @property
    def username(self) -> typing.Union[None, str]: ...
    @property
    def password(self) -> typing.Union[None, str]: ...
    @property
    def hostname(self) -> typing.Union[None, str]: ...
    @property
    def port(self) -> typing.Optional[int]: ...
    @property
    def is_secure(self) -> bool: ...
    def replace(self, **kwargs: typing.Any) -> URL: ...
    def include_query_params(self, **kwargs: typing.Any) -> URL: ...
    def replace_query_params(self, **kwargs: typing.Any) -> URL: ...
    def remove_query_params(
        self, keys: typing.Union[str, typing.Sequence[str]]
    ) -> URL: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class URLPath(str):
    """
    A URL path string that may also hold an associated protocol and/or host.
    Used by the routing to return `url_path_for` matches.
    """

    def __new__(cls, path: str, protocol: str = ..., host: str = ...) -> URLPath: ...
    def __init__(self, path: str, protocol: str = ..., host: str = ...) -> None: ...
    def make_absolute_url(self, base_url: typing.Union[str, URL]) -> str: ...

class Secret:
    """
    Holds a string value that should not be revealed in tracebacks etc.
    You should cast the value to `str` at the point it is required.
    """

    def __init__(self, value: str) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class CommaSeparatedStrings(Sequence):
    def __init__(self, value: typing.Union[str, typing.Sequence[str]]) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: typing.Union[int, slice]) -> typing.Any: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class ImmutableMultiDict(typing.Mapping):
    def __init__(
        self,
        *args: typing.Union[
            ImmutableMultiDict,
            typing.Mapping,
            typing.List[typing.Tuple[typing.Any, typing.Any]],
        ],
        **kwargs: typing.Any
    ) -> None: ...
    def getlist(self, key: typing.Any) -> typing.List[typing.Any]: ...
    def keys(self) -> typing.KeysView: ...
    def values(self) -> typing.ValuesView: ...
    def items(self) -> typing.ItemsView: ...
    def multi_items(self) -> typing.List[typing.Tuple[str, str]]: ...
    def get(self, key: typing.Any, default: typing.Any = ...) -> typing.Any: ...
    def __getitem__(self, key: typing.Any) -> str: ...
    def __contains__(self, key: typing.Any) -> bool: ...
    def __iter__(self) -> typing.Iterator[typing.Any]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...

class MultiDict(ImmutableMultiDict):
    def __setitem__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __delitem__(self, key: typing.Any) -> None: ...
    def pop(self, key: typing.Any, default: typing.Any = ...) -> typing.Any: ...
    def popitem(self) -> typing.Tuple: ...
    def poplist(self, key: typing.Any) -> typing.List: ...
    def clear(self) -> None: ...
    def setdefault(self, key: typing.Any, default: typing.Any = ...) -> typing.Any: ...
    def setlist(self, key: typing.Any, values: typing.List) -> None: ...
    def append(self, key: typing.Any, value: typing.Any) -> None: ...
    def update(
        self,
        *args: typing.Union[
            MultiDict, typing.Mapping, typing.List[typing.Tuple[typing.Any, typing.Any]]
        ],
        **kwargs: typing.Any
    ) -> None: ...

class QueryParams(ImmutableMultiDict):
    """
    An immutable multidict.
    """

    def __init__(
        self,
        *args: typing.Union[
            ImmutableMultiDict,
            typing.Mapping,
            typing.List[typing.Tuple[typing.Any, typing.Any]],
            str,
            bytes,
        ],
        **kwargs: typing.Any
    ) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class UploadFile:
    """
    An uploaded file included as part of the request data.
    """

    spool_max_size = ...
    def __init__(
        self, filename: str, file: typing.IO = ..., content_type: str = ...
    ) -> None: ...
    async def write(self, data: typing.Union[bytes, str]) -> None: ...
    async def read(self, size: int = ...) -> typing.Union[bytes, str]: ...
    async def seek(self, offset: int) -> None: ...
    async def close(self) -> None: ...

class FormData(ImmutableMultiDict):
    """
    An immutable multidict, containing both file uploads and text input.
    """

    def __init__(
        self,
        *args: typing.Union[
            FormData,
            typing.Mapping[str, typing.Union[str, UploadFile]],
            typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]],
        ],
        **kwargs: typing.Union[str, UploadFile]
    ) -> None: ...
    async def close(self) -> None: ...

class Headers(typing.Mapping[str, str]):
    """
    An immutable, case-insensitive multidict.
    """

    def __init__(
        self,
        headers: typing.Mapping[str, str] = ...,
        raw: typing.List[typing.Tuple[bytes, bytes]] = ...,
        scope: Scope = ...,
    ) -> None: ...
    @property
    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]: ...
    def keys(self) -> typing.List[str]: ...
    def values(self) -> typing.List[str]: ...
    def items(self) -> typing.List[typing.Tuple[str, str]]: ...
    def get(self, key: str, default: typing.Any = ...) -> typing.Any: ...
    def getlist(self, key: str) -> typing.List[str]: ...
    def mutablecopy(self) -> MutableHeaders: ...
    def __getitem__(self, key: str) -> str: ...
    def __contains__(self, key: typing.Any) -> bool: ...
    def __iter__(self) -> typing.Iterator[typing.Any]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...

class MutableHeaders(Headers):
    def __setitem__(self, key: str, value: str) -> None:
        """
        Set the header `key` to `value`, removing any duplicate entries.
        Retains insertion order.
        """
        ...
    def __delitem__(self, key: str) -> None:
        """
        Remove the header `key`.
        """
        ...
    @property
    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]: ...
    def setdefault(self, key: str, value: str) -> str:
        """
        If the header `key` does not exist, then set it to `value`.
        Returns the header value.
        """
        ...
    def update(self, other: dict) -> None: ...
    def append(self, key: str, value: str) -> None:
        """
        Append a header, preserving any duplicate entries.
        """
        ...
    def add_vary_header(self, vary: str) -> None: ...

class State:
    """
    An object that can be used to store arbitrary state.

    Used for `request.state` and `app.state`.
    """

    def __init__(self, state: typing.Dict = ...) -> None: ...
    def __setattr__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __getattr__(self, key: typing.Any) -> typing.Any: ...
    def __delattr__(self, key: typing.Any) -> None: ...
