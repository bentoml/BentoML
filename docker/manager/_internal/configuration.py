import os
import re
import typing as t
import logging
from typing import TYPE_CHECKING

import fs
import yaml
import attrs
import attrs.converters
from simple_di import inject
from simple_di import Provide
from simple_di import container
from simple_di.providers import SingletonFactory

from .exceptions import ManagerException
from ._gen_manifest import gen_manifest
from ._gen_manifest import DOCKER_DIRECTORY
from ._gen_manifest import MANIFEST_FILENAME

if TYPE_CHECKING:
    from fs.base import FS

    from .types import GenericDict

logger = logging.getLogger(__name__)

MANIFEST_GENERATED_STRING = "# NOTE: Partially generated by `manager create-manifest`\n"

# release entry should always include CUDA support :)
RELEASE_PREFIX = "w_cuda_v"
RELEASE_KEY_RGX = re.compile(rf"{RELEASE_PREFIX}([\d\.]+)(?:_(\w+))?$")

SUPPORTED_OS_RELEASES = (
    "debian11",
    "debian10",
    "ubi8",
    "ubi7",
    "amazonlinux2",
    "alpine3.14",
)


def _provider_converter(provider: str) -> str:
    if "quay" in provider.lower():
        assert provider in os.environ
        return "quay"
    return provider


@attrs.define
class DockerRegistry:
    url: str
    user: str
    password: str
    password_type: str = attrs.field(
        validator=attrs.validators.in_(["envars", "stdin"])
    )
    provider: str = attrs.field(converter=_provider_converter)
    entrypoint: t.Optional[str] = attrs.field(
        converter=attrs.converters.default_if_none(""), default=None
    )


@container
class ManagerContainerClass:

    root_dir = DOCKER_DIRECTORY

    default_name = "bento-server"
    default_manifest = MANIFEST_FILENAME.format("bento-server", "11.5.1")

    @SingletonFactory
    @staticmethod
    def root_fs() -> "FS":
        return fs.open_fs(DOCKER_DIRECTORY.__fspath__())

    @SingletonFactory
    @staticmethod
    def default_context() -> "t.Tuple[GenericDict, ...]":
        if not DOCKER_DIRECTORY.joinpath(
            "manifest", MANIFEST_FILENAME.format("bento-server", "11.5.1")
        ).exists():
            gen_manifest(
                "bento-server",
                "11.5.1",
                SUPPORTED_OS_RELEASES,
                overwrite=False,
                docker_fs=fs.open_fs(DOCKER_DIRECTORY.__fspath__()),
                registries=["docker.io", "ecr"],
            )

        return get_manifest_info(docker_package="bento-server", cuda_version="11.5.1")


DockerManagerContainer = ManagerContainerClass()


@inject
def get_manifest_info(
    *,
    docker_package: str,
    cuda_version: str,
    docker_fs_: "FS" = Provide[DockerManagerContainer.root_fs],
) -> "t.Tuple[GenericDict, ...]":
    manifest_fs = docker_fs_.opendir("manifest")
    fname = MANIFEST_FILENAME.format(docker_package, cuda_version)
    if not manifest_fs.exists(fname):
        raise ManagerException(f"{fname} doesn't exist under manifest directory.")

    with manifest_fs.open(fname, "r", encoding="utf-8") as f:
        if f.readline() != MANIFEST_GENERATED_STRING:
            logger.exception(
                f"{docker_package} should be initially generated with `manager create-manifest`"
            )
        manifest = yaml.load(f, Loader=yaml.FullLoader)
        manifest.pop("common")

    distros = {}
    for key in manifest.copy():
        if RELEASE_KEY_RGX.match(key):
            distros[key] = manifest.pop(key)

    registries = {
        reg: DockerRegistry(
            user=reg_ctx["user"],
            password_type=reg_ctx["password_type"],
            password=reg_ctx["password"],
            provider=reg_ctx["provider"],
            url=reg_ctx["url"],
        )
        for reg, reg_ctx in manifest.items()
    }

    # manifest should only have releases versions + registries
    return distros, registries
