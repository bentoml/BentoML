"""
This type stub file was generated by pyright.
"""

from decimal import Decimal
from enum import Enum
from pathlib import Path
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    ClassVar,
    Dict,
    List,
    Optional,
    Pattern,
    Set,
    Tuple,
    Type,
    Union,
)
from uuid import UUID
from weakref import WeakSet

from .typing import CallableGenerator

__all__ = [
    "NoneStr",
    "NoneBytes",
    "StrBytes",
    "NoneStrBytes",
    "StrictStr",
    "ConstrainedBytes",
    "conbytes",
    "ConstrainedList",
    "conlist",
    "ConstrainedSet",
    "conset",
    "ConstrainedStr",
    "constr",
    "PyObject",
    "ConstrainedInt",
    "conint",
    "PositiveInt",
    "NegativeInt",
    "NonNegativeInt",
    "NonPositiveInt",
    "ConstrainedFloat",
    "confloat",
    "PositiveFloat",
    "NegativeFloat",
    "NonNegativeFloat",
    "NonPositiveFloat",
    "ConstrainedDecimal",
    "condecimal",
    "UUID1",
    "UUID3",
    "UUID4",
    "UUID5",
    "FilePath",
    "DirectoryPath",
    "Json",
    "JsonWrapper",
    "SecretStr",
    "SecretBytes",
    "StrictBool",
    "StrictBytes",
    "StrictInt",
    "StrictFloat",
    "PaymentCardNumber",
    "ByteSize",
]
NoneStr = Optional[str]
NoneBytes = Optional[bytes]
StrBytes = Union[str, bytes]
NoneStrBytes = Optional[StrBytes]
OptionalInt = Optional[int]
OptionalIntFloat = Union[OptionalInt, float]
OptionalIntFloatDecimal = Union[OptionalIntFloat, Decimal]
StrIntFloat = Union[str, int, float]
if TYPE_CHECKING:
    ModelOrDc = Type[Union["BaseModel", "Dataclass"]]
T = ...
_DEFINED_TYPES: WeakSet[type] = ...

class ConstrainedNumberMeta(type):
    def __new__(cls, name: str, bases: Any, dct: Dict[str, Any]) -> ConstrainedInt: ...

if TYPE_CHECKING:
    StrictBool = bool
else: ...

class ConstrainedInt(int, metaclass=ConstrainedNumberMeta):
    strict: bool = ...
    gt: OptionalInt = ...
    ge: OptionalInt = ...
    lt: OptionalInt = ...
    le: OptionalInt = ...
    multiple_of: OptionalInt = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...

def conint(
    *,
    strict: bool = ...,
    gt: int = ...,
    ge: int = ...,
    lt: int = ...,
    le: int = ...,
    multiple_of: int = ...
) -> Type[int]: ...

if TYPE_CHECKING:
    PositiveInt = int
    NegativeInt = int
    NonPositiveInt = int
    NonNegativeInt = int
    StrictInt = int
else: ...

class ConstrainedFloat(float, metaclass=ConstrainedNumberMeta):
    strict: bool = ...
    gt: OptionalIntFloat = ...
    ge: OptionalIntFloat = ...
    lt: OptionalIntFloat = ...
    le: OptionalIntFloat = ...
    multiple_of: OptionalIntFloat = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...

def confloat(
    *,
    strict: bool = ...,
    gt: float = ...,
    ge: float = ...,
    lt: float = ...,
    le: float = ...,
    multiple_of: float = ...
) -> Type[float]: ...

if TYPE_CHECKING:
    PositiveFloat = float
    NegativeFloat = float
    NonPositiveFloat = float
    NonNegativeFloat = float
    StrictFloat = float
else: ...

class ConstrainedBytes(bytes):
    strip_whitespace = ...
    to_lower = ...
    min_length: OptionalInt = ...
    max_length: OptionalInt = ...
    strict: bool = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...

def conbytes(
    *,
    strip_whitespace: bool = ...,
    to_lower: bool = ...,
    min_length: int = ...,
    max_length: int = ...
) -> Type[bytes]: ...

if TYPE_CHECKING:
    StrictBytes = bytes
else: ...

class ConstrainedStr(str):
    strip_whitespace = ...
    to_lower = ...
    min_length: OptionalInt = ...
    max_length: OptionalInt = ...
    curtail_length: OptionalInt = ...
    regex: Optional[Pattern[str]] = ...
    strict = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def validate(cls, value: Union[str]) -> Union[str]: ...

def constr(
    *,
    strip_whitespace: bool = ...,
    to_lower: bool = ...,
    strict: bool = ...,
    min_length: int = ...,
    max_length: int = ...,
    curtail_length: int = ...,
    regex: str = ...
) -> Type[str]: ...

if TYPE_CHECKING:
    StrictStr = str
else: ...

class ConstrainedSet(set):
    __origin__ = set
    __args__: Set[Type[T]]
    min_items: Optional[int] = ...
    max_items: Optional[int] = ...
    item_type: Type[T]
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def set_length_validator(cls, v: Optional[Set[T]]) -> Optional[Set[T]]: ...

def conset(
    item_type: Type[T], *, min_items: int = ..., max_items: int = ...
) -> Type[Set[T]]: ...

class ConstrainedList(list):
    __origin__ = list
    __args__: Tuple[Type[T], ...]
    min_items: Optional[int] = ...
    max_items: Optional[int] = ...
    item_type: Type[T]
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def list_length_validator(cls, v: Optional[List[T]]) -> Optional[List[T]]: ...

def conlist(
    item_type: Type[T], *, min_items: int = ..., max_items: int = ...
) -> Type[List[T]]: ...

if TYPE_CHECKING:
    PyObject = Callable[..., Any]
else: ...

class ConstrainedDecimal(Decimal, metaclass=ConstrainedNumberMeta):
    gt: OptionalIntFloatDecimal = ...
    ge: OptionalIntFloatDecimal = ...
    lt: OptionalIntFloatDecimal = ...
    le: OptionalIntFloatDecimal = ...
    max_digits: OptionalInt = ...
    decimal_places: OptionalInt = ...
    multiple_of: OptionalIntFloatDecimal = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def validate(cls, value: Decimal) -> Decimal: ...

def condecimal(
    *,
    gt: Decimal = ...,
    ge: Decimal = ...,
    lt: Decimal = ...,
    le: Decimal = ...,
    max_digits: int = ...,
    decimal_places: int = ...,
    multiple_of: Decimal = ...
) -> Type[Decimal]: ...

if TYPE_CHECKING:
    UUID1 = UUID
    UUID3 = UUID
    UUID4 = UUID
    UUID5 = UUID
else: ...
if TYPE_CHECKING:
    FilePath = Path
    DirectoryPath = Path
else: ...

class JsonWrapper: ...

class JsonMeta(type):
    def __getitem__(self, t: Type[Any]) -> Type[JsonWrapper]: ...

if TYPE_CHECKING:
    Json = str
else: ...

class SecretStr:
    min_length: OptionalInt = ...
    max_length: OptionalInt = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def validate(cls, value: Any) -> SecretStr: ...
    def __init__(self, value: str) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def display(self) -> str: ...
    def get_secret_value(self) -> str: ...

class SecretBytes:
    min_length: OptionalInt = ...
    max_length: OptionalInt = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def validate(cls, value: Any) -> SecretBytes: ...
    def __init__(self, value: bytes) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def display(self) -> str: ...
    def get_secret_value(self) -> bytes: ...

class PaymentCardBrand(str, Enum):
    amex = ...
    mastercard = ...
    visa = ...
    other = ...
    def __str__(self) -> str: ...

class PaymentCardNumber(str):
    """
    Based on: https://en.wikipedia.org/wiki/Payment_card_number
    """

    strip_whitespace: ClassVar[bool] = ...
    min_length: ClassVar[int] = ...
    max_length: ClassVar[int] = ...
    bin: str
    last4: str
    brand: PaymentCardBrand
    def __init__(self, card_number: str) -> None: ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @property
    def masked(self) -> str: ...
    @classmethod
    def validate_digits(cls, card_number: str) -> str: ...
    @classmethod
    def validate_luhn_check_digit(cls, card_number: str) -> str:
        """
        Based on: https://en.wikipedia.org/wiki/Luhn_algorithm
        """
        ...
    @classmethod
    def validate_length_for_brand(
        cls, card_number: PaymentCardNumber
    ) -> PaymentCardNumber:
        """
        Validate length based on BIN for major brands:
        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)
        """
        ...

BYTE_SIZES = ...
byte_string_re = ...

class ByteSize(int):
    @classmethod
    def __get_validators__(cls) -> CallableGenerator: ...
    @classmethod
    def validate(cls, v: StrIntFloat) -> ByteSize: ...
    def human_readable(self, decimal: bool = ...) -> str: ...
    def to(self, unit: str) -> float: ...
