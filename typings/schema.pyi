"""
This type stub file was generated by pyright.
"""
from typing import Any, Callable, Dict, Generic, List
from typing import Literal as LiteralType
from typing import Optional as OptionalType
from typing import Protocol, Tuple, TypeVar, Union, overload

__version__: str = ...

GenericType = Union["Schema", "And[Any, Any]", "Or", "Use", "Optional", "Regex", "Literal", "Const"]
DictType = Dict[Union[str, GenericType], Any]

_KT = TypeVar("_KT")
_VT = TypeVar("_VT")
_KT_co = TypeVar("_KT_co", covariant=True)
_VT_co = TypeVar("_VT_co", covariant=True)


class LambdaProtocol(Protocol[_KT_co, _VT_co]):
    @overload
    def __call__(*args: Any, **kwargs: Any) -> Any: ...
    @overload
    def __call__(*args: _KT, **kwargs: _VT) -> Any: ...

class SchemaError(Exception):
    """Error during Schema validation."""
    @overload
    def __init__(self, autos: str, errors: str=...) -> None:
        ...
    @overload
    def __init__(self, autos: List[str], errors: List[Exception]=...) -> None:
        ...
    @overload
    def __init__(self, autos: List[str], errors: Exception=...) -> None:
        ...
    @overload
    def __init__(self, autos: List[str], errors: None=...) -> None:
        ...

    @property
    def code(self) -> str:
        """
        Removes duplicates values in auto and error list.
        parameters.
        """
        ...


class SchemaWrongKeyError(SchemaError): ...


class SchemaMissingKeyError(SchemaError): ...


class SchemaOnlyOneAllowedError(SchemaError): ...


class SchemaForbiddenKeyError(SchemaError): ...


class SchemaUnexpectedTypeError(SchemaError): ...


class And(Generic[_KT, _VT]):
    """
    Utility function to combine validation directives in AND Boolean fashion.
    """
    @overload
    def __init__(self, *args: _KT, error: str=...,schema: OptionalType[DictType]=...,ignore_extra_keys: bool=...) -> None:
        ...
    @overload
    def __init__(self, *args: LambdaProtocol[_KT, _VT], error: List[str]=...,schema: OptionalType[DictType]=...,ignore_extra_keys: bool=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def args(self) -> Tuple[_VT, ...]: ...

    def validate(self, data: _VT) -> _VT: ...



class Or(And):
    """Utility function to combine validation directives in a OR Boolean
    fashion."""
    @overload
    def __init__(self, *args: Any, error: str=...,schema: OptionalType[DictType]=...,ignore_extra_keys: bool=... , only_one: bool=...,) -> None:
        ...
    @overload
    def __init__(self, *args: Any, error: List[str]=...,schema: OptionalType[DictType]=...,ignore_extra_keys: bool=... , only_one: bool=...,) -> None:
        ...

    def reset(self) -> None:
        ...

    def validate(self, data: DictType) -> DictType:
        """
        Validate data using sub defined schema/expressions ensuring at least
        one value is valid.
        :param data: data to be validated by provided schema.
        :return: return validated data if not validation
        """
        ...



class Regex:
    """
    Enables schema.py to validate string using regular expressions.
    """
    NAMES: List[str]= ...
    def __init__(self, pattern_str: str, flags: OptionalType[int]=..., error: OptionalType[str]=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def pattern_str(self) -> str:
        """The pattern for the represented regular expression"""
        ...

    def validate(self, data: str) -> str:
        """
        Validated data using defined regex.
        :param data: data to be validated
        :return: return validated data.
        """
        ...



class Use:
    """
    For more general use cases, you can use the Use class to transform
    the data while it is being validate.
    """
    def __init__(self, callable_: Callable[..., Any], error: OptionalType[str]=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    def validate(self, data: DictType) -> DictType:
        ...


COMPARABLE=LiteralType["0"]
CALLABLE=LiteralType["1"]
VALIDATOR=LiteralType["2"]
TYPE=LiteralType["3"]
DICT = LiteralType["4"]
ITERABLE=LiteralType["5"]

def _priority(s: type) -> Union[CALLABLE, COMPARABLE, VALIDATOR, TYPE, DICT, ITERABLE]: ...

class Schema:
    """
    Entry point of the library, use this class to instantiate validation
    schema for the data that will be validated.
    """
    def __init__(self, schema: DictType, error: OptionalType[str]=..., ignore_extra_keys: OptionalType[bool]=..., name: OptionalType[str]=..., description: OptionalType[str]=..., as_reference: OptionalType[bool]=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def schema(self) -> DictType:
        ...

    @property
    def description(self) -> str:
        ...

    @property
    def name(self) -> str:
        ...

    @property
    def ignore_extra_keys(self) -> bool:
        ...

    @staticmethod
    def _dict_key_priority(s: type) -> Union[float, int]: ...

    @staticmethod
    def _is_optional_type(s: type) -> bool:...

    def is_valid(self, data: Any) -> bool:
        """Return whether the given data has passed all the validations
        that were specified in the given schema.
        """
        ...

    def _prepend_schema_name(self, message: str) -> str:...

    @overload
    def validate(self, data: DictType) -> DictType:
        ...
    @overload
    def validate(self, data: Any) -> DictType:
        ...

    def json_schema(self, schema_id: Any, use_refs: OptionalType[bool]=...) -> Dict[str, Any]:
        """Generate a draft-07 JSON schema dict representing the Schema.
        This method must be called with a schema_id.

        :param schema_id: The value of the $id on the main schema
        :param use_refs: Enable reusing object references in the resulting JSON schema.
                         Schemas with references are harder to read by humans, but are a lot smaller when there
                         is a lot of reuse
        """
        ...



class Optional(Schema):
    """Marker for an optional part of the validation Schema."""
    _MARKER: object = ...
    default: object
    key: str
    def __init__(self, schema: str, error: OptionalType[str]=..., ignore_extra_keys: OptionalType[bool]=..., name: OptionalType[str]=..., description: OptionalType[str]=..., as_reference: OptionalType[bool]=..., default: OptionalType[Any]=...) -> None:
        ...

    def __hash__(self) -> int:
        ...

    def __eq__(self, other: Optional) -> bool:
        ...

    def reset(self) -> None:
        ...


_HookCallback = Callable[[str, DictType, str], SchemaError]

class Hook(Schema):
    key: DictType
    def __init__(self, schema: DictType, error: OptionalType[str]=..., ignore_extra_keys: OptionalType[bool]=..., name: OptionalType[str]=..., description: OptionalType[str]=..., as_reference: OptionalType[bool]=..., handler: OptionalType[_HookCallback]=...) -> None:
        ...



class Forbidden(Hook):
    handler: Callable[[str, DictType, str], SchemaForbiddenKeyError]
    def __init__(self, schema: DictType, error: OptionalType[str]=..., ignore_extra_keys: OptionalType[bool]=..., name: OptionalType[str]=..., description: OptionalType[str]=..., as_reference: OptionalType[bool]=...) -> None:
        ...


class Literal(object):
    def __init__(self, value: str, description: OptionalType[str]=...) -> None:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def description(self) -> str:
        ...

    @property
    def schema(self) -> str:
        ...



class Const(Schema):
    def validate(self, data: DictType) -> DictType:
        ...

def _callable_str(callable_: Callable[..., Any]) -> str: ...

def _plural_s(sized: str) -> str: ...

__all__ = ["Schema", "And", "Or", "Regex", "Optional", "Use", "Forbidden", "Const", "Literal", "SchemaError", "SchemaWrongKeyError", "SchemaMissingKeyError", "SchemaForbiddenKeyError", "SchemaUnexpectedTypeError", "SchemaOnlyOneAllowedError"]
