from dataclasses import dataclass
from typing import Optional, Tuple, Union
import tensorflow as tf
from .file_utils import ModelOutput

logger = ...

@dataclass
class TFGreedySearchDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFGreedySearchEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[Tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[Tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFSampleDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFSampleEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[Tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[Tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSearchDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSearchEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[Tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[Tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSampleDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSampleEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[Tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[Tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[Tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[Tuple[Tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[Tuple[Tuple[tf.Tensor]]] = ...

TFGreedySearchOutput = Union[
    TFGreedySearchEncoderDecoderOutput, TFGreedySearchDecoderOnlyOutput
]
TFSampleOutput = Union[TFSampleEncoderDecoderOutput, TFSampleDecoderOnlyOutput]
TFBeamSearchOutput = Union[
    TFBeamSearchEncoderDecoderOutput, TFBeamSearchDecoderOnlyOutput
]
TFBeamSampleOutput = Union[
    TFBeamSampleEncoderDecoderOutput, TFBeamSampleDecoderOnlyOutput
]

class TFGenerationMixin:
    def prepare_inputs_for_generation(self, inputs, **kwargs): ...
    def generate(
        self,
        input_ids=...,
        max_length=...,
        min_length=...,
        do_sample=...,
        early_stopping=...,
        num_beams=...,
        temperature=...,
        top_k=...,
        top_p=...,
        repetition_penalty=...,
        bad_words_ids=...,
        bos_token_id=...,
        pad_token_id=...,
        eos_token_id=...,
        length_penalty=...,
        no_repeat_ngram_size=...,
        num_return_sequences=...,
        attention_mask=...,
        decoder_start_token_id=...,
        use_cache=...,
        output_scores=...,
        output_attentions=...,
        output_hidden_states=...,
        return_dict_in_generate=...,
        forced_bos_token_id=...,
        forced_eos_token_id=...,
        **model_kwargs
    ) -> Union[
        TFGreedySearchOutput,
        TFSampleOutput,
        TFBeamSearchOutput,
        TFBeamSampleOutput,
        tf.Tensor,
    ]: ...
    def adjust_logits_during_generation(
        self,
        logits,
        cur_len,
        max_length,
        forced_bos_token_id,
        forced_eos_token_id,
        **kwargs
    ): ...

def calc_banned_ngram_tokens(
    prev_input_ids, num_hypos, no_repeat_ngram_size, cur_len
): ...
def calc_banned_bad_words_ids(prev_input_ids, bad_words_ids): ...
def tf_top_k_top_p_filtering(
    logits, top_k=..., top_p=..., filter_value=..., min_tokens_to_keep=...
): ...
def scatter_values_on_batch_indices(values, batch_indices): ...
def set_tensor_by_indices_to_value(tensor, indices, value): ...
def sample_without_replacement(logits, num_samples): ...
def shape_list(x): ...

class BeamHypotheses:
    def __init__(
        self, num_beams, max_length, length_penalty, early_stopping
    ) -> None: ...
    def __len__(self): ...
    def add(self, hyp, sum_logprobs): ...
