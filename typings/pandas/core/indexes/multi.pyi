from typing import TYPE_CHECKING, Any, Callable, Hashable, Iterable, Sequence
import numpy as np
from pandas import DataFrame, Series
from pandas._libs import index as libindex
from pandas._libs.hashtable import duplicated
from pandas._typing import Shape
from pandas.core.indexes.base import Index, _index_shared_docs
from pandas.core.indexes.frozen import FrozenList
from pandas.util._decorators import (
    Appender,
    cache_readonly,
    deprecate_nonkeyword_arguments,
    doc,
)

if TYPE_CHECKING: ...
_index_doc_kwargs = ...

class MultiIndexUIntEngine(libindex.BaseMultiIndexCodesEngine, libindex.UInt64Engine):
    _base = libindex.UInt64Engine

class MultiIndexPyIntEngine(libindex.BaseMultiIndexCodesEngine, libindex.ObjectEngine):
    _base = libindex.ObjectEngine

def names_compat(meth): ...

class MultiIndex(Index):
    _hidden_attrs = ...
    _typ = ...
    _names = ...
    _levels = ...
    _codes = ...
    _comparables = ...
    sortorder: int | None
    def __new__(
        cls,
        levels=...,
        codes=...,
        sortorder=...,
        names=...,
        dtype=...,
        copy=...,
        name=...,
        verify_integrity: bool = ...,
    ): ...
    @classmethod
    def from_arrays(cls, arrays, sortorder=..., names=...) -> MultiIndex: ...
    @classmethod
    @names_compat
    def from_tuples(
        cls,
        tuples: Iterable[tuple[Hashable, ...]],
        sortorder: int | None = ...,
        names: Sequence[Hashable] | None = ...,
    ) -> MultiIndex: ...
    @classmethod
    def from_product(cls, iterables, sortorder=..., names=...) -> MultiIndex: ...
    @classmethod
    def from_frame(cls, df: DataFrame, sortorder=..., names=...) -> MultiIndex: ...
    @property
    def values(self) -> np.ndarray: ...
    @property
    def array(self): ...
    @cache_readonly
    def dtypes(self) -> Series: ...
    def __len__(self) -> int: ...
    @cache_readonly
    def levels(self) -> FrozenList: ...
    @deprecate_nonkeyword_arguments(version=None, allowed_args=["self", "levels"])
    def set_levels(
        self, levels, level=..., inplace=..., verify_integrity: bool = ...
    ): ...
    @property
    def nlevels(self) -> int: ...
    @property
    def levshape(self) -> Shape: ...
    @property
    def codes(self): ...
    @deprecate_nonkeyword_arguments(version=None, allowed_args=["self", "codes"])
    def set_codes(
        self, codes, level=..., inplace=..., verify_integrity: bool = ...
    ): ...
    def copy(self, names=..., dtype=..., levels=..., codes=..., deep=..., name=...): ...
    def __array__(self, dtype=...) -> np.ndarray: ...
    def view(self, cls=...): ...
    @doc(Index.__contains__)
    def __contains__(self, key: Any) -> bool: ...
    @cache_readonly
    def dtype(self) -> np.dtype: ...
    @doc(Index.memory_usage)
    def memory_usage(self, deep: bool = ...) -> int: ...
    @cache_readonly
    def nbytes(self) -> int: ...
    def format(
        self,
        name: bool | None = ...,
        formatter: Callable | None = ...,
        na_rep: str | None = ...,
        names: bool = ...,
        space: int = ...,
        sparsify=...,
        adjoin: bool = ...,
    ) -> list: ...
    names = ...
    @cache_readonly
    def inferred_type(self) -> str: ...
    @cache_readonly
    def is_monotonic_increasing(self) -> bool: ...
    @cache_readonly
    def is_monotonic_decreasing(self) -> bool: ...
    @doc(Index.duplicated)
    def duplicated(self, keep=...) -> np.ndarray: ...
    _duplicated = ...
    def fillna(self, value=..., downcast=...): ...
    @doc(Index.dropna)
    def dropna(self, how: str = ...) -> MultiIndex: ...
    def get_level_values(self, level): ...
    @doc(Index.unique)
    def unique(self, level=...): ...
    def to_frame(self, index: bool = ..., name=...) -> DataFrame: ...
    def to_flat_index(self) -> Index: ...
    def is_lexsorted(self) -> bool: ...
    @property
    def lexsort_depth(self): ...
    def remove_unused_levels(self) -> MultiIndex: ...
    def __reduce__(self): ...
    def __getitem__(self, key): ...
    @Appender(_index_shared_docs["take"] % _index_doc_kwargs)
    def take(
        self: MultiIndex,
        indices,
        axis: int = ...,
        allow_fill: bool = ...,
        fill_value=...,
        **kwargs
    ) -> MultiIndex: ...
    def append(self, other): ...
    def argsort(self, *args, **kwargs) -> np.ndarray: ...
    @Appender(_index_shared_docs["repeat"] % _index_doc_kwargs)
    def repeat(self, repeats: int, axis=...) -> MultiIndex: ...
    def drop(self, codes, level=..., errors=...): ...
    def swaplevel(self, i=..., j=...) -> MultiIndex: ...
    def reorder_levels(self, order) -> MultiIndex: ...
    def sortlevel(
        self, level=..., ascending: bool = ..., sort_remaining: bool = ...
    ) -> tuple[MultiIndex, np.ndarray]: ...
    def reindex(
        self, target, method=..., level=..., limit=..., tolerance=...
    ) -> tuple[MultiIndex, np.ndarray | None]: ...
    def get_slice_bound(
        self, label: Hashable | Sequence[Hashable], side: str, kind: str | None = ...
    ) -> int: ...
    def slice_locs(self, start=..., end=..., step=..., kind=...): ...
    def get_loc(self, key, method=...): ...
    def get_loc_level(self, key, level=..., drop_level: bool = ...): ...
    def get_locs(self, seq): ...
    def truncate(self, before=..., after=...) -> MultiIndex: ...
    def equals(self, other: object) -> bool: ...
    def equal_levels(self, other: MultiIndex) -> bool: ...
    @doc(Index.astype)
    def astype(self, dtype, copy: bool = ...): ...
    def insert(self, loc: int, item) -> MultiIndex: ...
    def delete(self, loc) -> MultiIndex: ...
    @doc(Index.isin)
    def isin(self, values, level=...) -> np.ndarray: ...
    @deprecate_nonkeyword_arguments(version=None, allowed_args=["self", "names"])
    def set_names(self, names, level=..., inplace: bool = ...) -> MultiIndex | None: ...
    rename = ...
    @deprecate_nonkeyword_arguments(version=None, allowed_args=["self"])
    def drop_duplicates(self, keep: str | bool = ...) -> MultiIndex: ...
    __add__ = ...
    __radd__ = ...
    __iadd__ = ...
    __sub__ = ...
    __rsub__ = ...
    __isub__ = ...
    __pow__ = ...
    __rpow__ = ...
    __mul__ = ...
    __rmul__ = ...
    __floordiv__ = ...
    __rfloordiv__ = ...
    __truediv__ = ...
    __rtruediv__ = ...
    __mod__ = ...
    __rmod__ = ...
    __divmod__ = ...
    __rdivmod__ = ...
    __neg__ = ...
    __pos__ = ...
    __abs__ = ...
    __inv__ = ...

def sparsify_labels(label_list, start: int = ..., sentinel=...): ...
def maybe_droplevels(index: Index, key) -> Index: ...
