from typing import TYPE_CHECKING
import numpy as np
from pandas import DataFrame
from pandas._libs.indexing import NDFrameIndexerBase
from pandas.core.indexes.api import Index
from pandas.util._decorators import doc

if TYPE_CHECKING: ...
_NS = ...

class _IndexSlice:
    def __getitem__(self, arg): ...

IndexSlice = ...

class IndexingError(Exception): ...

class IndexingMixin:
    @property
    def iloc(self) -> _iLocIndexer: ...
    @property
    def loc(self) -> _LocIndexer: ...
    @property
    def at(self) -> _AtIndexer: ...
    @property
    def iat(self) -> _iAtIndexer: ...

class _LocationIndexer(NDFrameIndexerBase):
    _valid_types: str
    axis = ...
    def __call__(self, axis=...): ...
    def __setitem__(self, key, value): ...
    def __getitem__(self, key): ...

@doc(IndexingMixin.loc)
class _LocIndexer(_LocationIndexer):
    _takeable: bool = ...
    _valid_types = ...

@doc(IndexingMixin.iloc)
class _iLocIndexer(_LocationIndexer):
    _valid_types = ...
    _takeable = ...

class _ScalarAccessIndexer(NDFrameIndexerBase):
    def __getitem__(self, key): ...
    def __setitem__(self, key, value): ...

@doc(IndexingMixin.at)
class _AtIndexer(_ScalarAccessIndexer):
    _takeable = ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value): ...

@doc(IndexingMixin.iat)
class _iAtIndexer(_ScalarAccessIndexer):
    _takeable = ...

def convert_to_index_sliceable(obj: DataFrame, key): ...
def check_bool_indexer(index: Index, key) -> np.ndarray: ...
def convert_missing_indexer(indexer): ...
def convert_from_missing_indexer_tuple(indexer, axes): ...
def maybe_convert_ix(*args): ...
def is_nested_tuple(tup, labels) -> bool: ...
def is_label_like(key) -> bool: ...
def need_slice(obj: slice) -> bool: ...
