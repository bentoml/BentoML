import contextlib
from abc import ABCMeta, abstractmethod
from ._multiprocessing_helpers import mp

if mp is not None: ...

class ParallelBackendBase(metaclass=ABCMeta):
    supports_timeout = ...
    supports_inner_max_num_threads = ...
    nesting_level = ...
    def __init__(
        self, nesting_level=..., inner_max_num_threads=..., **kwargs
    ) -> None: ...
    MAX_NUM_THREADS_VARS = ...
    TBB_ENABLE_IPC_VAR = ...
    @abstractmethod
    def effective_n_jobs(self, n_jobs): ...
    @abstractmethod
    def apply_async(self, func, callback=...): ...
    def configure(
        self, n_jobs=..., parallel=..., prefer=..., require=..., **backend_args
    ): ...
    def start_call(self): ...
    def stop_call(self): ...
    def terminate(self): ...
    def compute_batch_size(self): ...
    def batch_completed(self, batch_size, duration): ...
    def get_exceptions(self): ...
    def abort_everything(self, ensure_ready=...): ...
    def get_nested_backend(self): ...
    @contextlib.contextmanager
    def retrieval_context(self): ...
    @staticmethod
    def in_main_thread(): ...

class SequentialBackend(ParallelBackendBase):
    uses_threads = ...
    supports_sharedmem = ...
    def effective_n_jobs(self, n_jobs): ...
    def apply_async(self, func, callback=...): ...
    def get_nested_backend(self): ...

class PoolManagerMixin:
    _pool = ...
    def effective_n_jobs(self, n_jobs): ...
    def terminate(self): ...
    def apply_async(self, func, callback=...): ...
    def abort_everything(self, ensure_ready=...): ...

class AutoBatchingMixin:
    MIN_IDEAL_BATCH_DURATION = ...
    MAX_IDEAL_BATCH_DURATION = ...
    _DEFAULT_EFFECTIVE_BATCH_SIZE = ...
    _DEFAULT_SMOOTHED_BATCH_DURATION = ...
    def __init__(self, **kwargs) -> None: ...
    def compute_batch_size(self): ...
    def batch_completed(self, batch_size, duration): ...
    def reset_batch_stats(self): ...

class ThreadingBackend(PoolManagerMixin, ParallelBackendBase):
    supports_timeout = ...
    uses_threads = ...
    supports_sharedmem = ...
    def configure(self, n_jobs=..., parallel=..., **backend_args): ...

class MultiprocessingBackend(PoolManagerMixin, AutoBatchingMixin, ParallelBackendBase):
    supports_timeout = ...
    def effective_n_jobs(self, n_jobs): ...
    def configure(
        self, n_jobs=..., parallel=..., prefer=..., require=..., **memmappingpool_args
    ): ...
    def terminate(self): ...

class LokyBackend(AutoBatchingMixin, ParallelBackendBase):
    supports_timeout = ...
    supports_inner_max_num_threads = ...
    def configure(
        self,
        n_jobs=...,
        parallel=...,
        prefer=...,
        require=...,
        idle_worker_timeout=...,
        **memmappingexecutor_args
    ): ...
    def effective_n_jobs(self, n_jobs): ...
    def apply_async(self, func, callback=...): ...
    @staticmethod
    def wrap_future_result(future, timeout=...): ...
    def terminate(self): ...
    def abort_everything(self, ensure_ready=...): ...

class ImmediateResult:
    def __init__(self, batch) -> None: ...
    def get(self): ...

class SafeFunction:
    def __init__(self, func) -> None: ...
    def __call__(self, *args, **kwargs): ...

class FallbackToBackend(Exception):
    def __init__(self, backend) -> None: ...
