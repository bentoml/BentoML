import os
import re
import typing as t
import logging
from typing import TYPE_CHECKING
from pathlib import Path

import fs
import yaml
import attrs
import attrs.converters
from simple_di import inject
from simple_di import Provide
from simple_di import container
from yamlinclude import YamlIncludeConstructor
from manager._utils import as_posix
from manager._utils import raise_exception
from manager._exceptions import ManagerException
from simple_di.providers import SingletonFactory

if TYPE_CHECKING:
    from fs.base import FS
    from manager._types import GenericDict

logger = logging.getLogger(__name__)

MANIFEST_GENERATED_STRING = "# NOTE: Partially generated by `manager create-manifest`\n"
MANIFEST_FILENAME = "{}.cuda_v{}.yaml"

DOCKER_DIRECTORY = Path(os.path.dirname(__file__)).parent

# release entry should always include CUDA support :)
RELEASE_PREFIX = "w_cuda_v"
RELEASE_KEY_RGX = re.compile(rf"{RELEASE_PREFIX}([\d\.]+)(?:_(\w+))?$")


@raise_exception
def _provider_converter(provider: str) -> str:
    if "quay" in provider.lower():
        assert provider in os.environ
        return "quay"
    return provider


@attrs.define
class DockerRegistry:
    url: str
    user: str
    password: str
    password_type: str = attrs.field(
        validator=attrs.validators.in_(["envars", "stdin"])
    )
    provider: str = attrs.field(converter=_provider_converter)
    entrypoint: t.Optional[str] = attrs.field(
        converter=attrs.converters.default_if_none(""), default=None
    )


@container
class ManagerContainerClass:

    root_dir = DOCKER_DIRECTORY

    default_name = "bento-server"
    default_manifest = MANIFEST_FILENAME.format("bento-server", "11.5.1")

    @SingletonFactory
    @staticmethod
    def yaml_loader() -> t.Type[yaml.loader.FullLoader]:
        include_cls = YamlIncludeConstructor(base_dir=as_posix(DOCKER_DIRECTORY, "manager"), encoding="utf-8")  # type: ignore
        yaml.add_constructor(include_cls.DEFAULT_TAG_NAME, include_cls, yaml.FullLoader)
        return yaml.FullLoader

    @SingletonFactory
    @staticmethod
    def root_fs() -> "FS":
        return fs.open_fs(DOCKER_DIRECTORY.__fspath__())

    @SingletonFactory
    @staticmethod
    def default_context() -> "t.Tuple[GenericDict, ...]":
        return get_manifest_info(docker_package="bento-server", cuda_version="11.5.1")


DockerManagerContainer = ManagerContainerClass()


@inject
def load_manifest_yaml(
    docker_package: str,
    cuda_version: str,
    docker_fs_: "FS" = Provide[DockerManagerContainer.root_fs],
    loader: t.Type[yaml.loader.FullLoader] = Provide[
        DockerManagerContainer.yaml_loader
    ],
) -> "GenericDict":
    manifest_fs = docker_fs_.opendir("manifest")
    fname = MANIFEST_FILENAME.format(docker_package, cuda_version)
    if not manifest_fs.exists(fname):
        raise ManagerException(f"{fname} doesn't exist under manifest directory.")

    with manifest_fs.open(fname, "r", encoding="utf-8") as f:
        if f.readline() != MANIFEST_GENERATED_STRING:
            logger.exception(
                f"{docker_package} should be initially generated with `manager create-manifest`"
            )
        manifest = yaml.load(f, Loader=loader)
        manifest.pop("common")

    return manifest


@inject
def get_manifest_info(
    *,
    docker_package: str,
    cuda_version: str,
) -> "t.Tuple[GenericDict, ...]":
    manifest = load_manifest_yaml(
        docker_package=docker_package, cuda_version=cuda_version
    )

    distros = {}
    for key in manifest.copy():
        if RELEASE_KEY_RGX.match(key):
            distros[key] = manifest.pop(key)

    registries = {
        reg: DockerRegistry(
            user=reg_ctx["user"],
            password_type=reg_ctx["password_type"],
            password=reg_ctx["password"],
            provider=reg_ctx["provider"],
            url=reg_ctx["url"],
        )
        for reg, reg_ctx in manifest.items()
    }

    # manifest should only have releases versions + registries
    return distros, registries
