from typing import TYPE_CHECKING, Any, Iterator, Literal, Sequence
import numpy as np
from pandas._typing import ArrayLike, Dtype, FillnaOptions, PositionalIndexer, Shape
from pandas.core.dtypes.dtypes import ExtensionDtype
from pandas.util._decorators import Appender, Substitution

if TYPE_CHECKING:
    class ExtensionArraySupportsAnyAll("ExtensionArray"):
        def any(self, *, skipna: bool = ...) -> bool: ...
        def all(self, *, skipna: bool = ...) -> bool: ...

_extension_array_shared_docs: dict[str, str] = ...
ExtensionArrayT = ...

class ExtensionArray:
    _typ = ...
    def __getitem__(self, item: PositionalIndexer) -> ExtensionArray | Any: ...
    def __setitem__(self, key: int | slice | np.ndarray, value: Any) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __contains__(self, item: object) -> bool | np.bool_: ...
    def __eq__(self, other: Any) -> ArrayLike: ...
    def __ne__(self, other: Any) -> ArrayLike: ...
    def to_numpy(
        self, dtype: Dtype | None = ..., copy: bool = ..., na_value: Any=...
    ) -> np.ndarray[Any, np.dtype[Any]]: ...
    @property
    def dtype(self) -> ExtensionDtype: ...
    @property
    def shape(self) -> Shape: ...
    @property
    def size(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    def astype(self, dtype, copy=...): ...
    def isna(self) -> np.ndarray | ExtensionArraySupportsAnyAll: ...
    def argsort(
        self,
        ascending: bool = ...,
        kind: str = ...,
        na_position: str = ...,
        *args,
        **kwargs
    ) -> np.ndarray: ...
    def argmin(self, skipna: bool = ...) -> int: ...
    def argmax(self, skipna: bool = ...) -> int: ...
    def fillna(
        self,
        value: object | ArrayLike | None = ...,
        method: FillnaOptions | None = ...,
        limit: int | None = ...,
    ): ...
    def dropna(self): ...
    def shift(self, periods: int = ..., fill_value: object = ...) -> ExtensionArray: ...
    def unique(self: ExtensionArrayT) -> ExtensionArrayT: ...
    def searchsorted(self, value, side=..., sorter=...): ...
    def equals(self, other: object) -> bool: ...
    def isin(self, values) -> np.ndarray: ...
    def factorize(
        self, na_sentinel: int = ...
    ) -> tuple[np.ndarray, ExtensionArray]: ...
    @Substitution(klass="ExtensionArray")
    @Appender(_extension_array_shared_docs["repeat"])
    def repeat(self, repeats: int | Sequence[int], axis: int | None = ...): ...
    def take(
        self: ExtensionArrayT,
        indices: Sequence[int],
        *,
        allow_fill: bool = ...,
        fill_value: Any = ...
    ) -> ExtensionArrayT: ...
    def copy(self: ExtensionArrayT) -> ExtensionArrayT: ...
    def view(self, dtype: Dtype | None = ...) -> ArrayLike: ...
    def __repr__(self) -> str: ...
    def transpose(self, *axes: int) -> ExtensionArray: ...
    @property
    def T(self) -> ExtensionArray: ...
    def ravel(
        self, order: Literal["C", "F", "A", "K"] | None = ...
    ) -> ExtensionArray: ...
    __hash__: None
    def delete(self: ExtensionArrayT, loc) -> ExtensionArrayT: ...

class ExtensionOpsMixin: ...
class ExtensionScalarOpsMixin(ExtensionOpsMixin): ...
