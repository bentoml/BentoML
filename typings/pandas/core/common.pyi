import contextlib
from typing import TYPE_CHECKING, Any, Callable, Collection, Iterable, Iterator
import numpy as np
from pandas import Index
from pandas._typing import AnyArrayLike, NpDtype, Scalar, T

if TYPE_CHECKING: ...

class SettingWithCopyError(ValueError): ...
class SettingWithCopyWarning(Warning): ...

def flatten(line): ...
def consensus_name_attr(objs): ...
def is_bool_indexer(key: Any) -> bool: ...
def cast_scalar_indexer(val, warn_float: bool = ...): ...
def not_none(*args): ...
def any_none(*args) -> bool: ...
def all_none(*args) -> bool: ...
def any_not_none(*args) -> bool: ...
def all_not_none(*args) -> bool: ...
def count_not_none(*args) -> int: ...
def asarray_tuplesafe(values, dtype: NpDtype | None = ...) -> np.ndarray: ...
def index_labels_to_array(labels, dtype: NpDtype | None = ...) -> np.ndarray: ...
def maybe_make_list(obj): ...
def maybe_iterable_to_list(obj: Iterable[T] | T) -> Collection[T] | T: ...
def is_null_slice(obj) -> bool: ...
def is_true_slices(line) -> list[bool]: ...
def is_full_slice(obj, line: int) -> bool: ...
def get_callable_name(obj): ...
def apply_if_callable(maybe_callable, obj, **kwargs): ...
def standardize_mapping(into): ...
def random_state(state=...): ...
def pipe(
    obj, func: Callable[..., T] | tuple[Callable[..., T], str], *args, **kwargs
) -> T: ...
def get_rename_function(mapper): ...
def convert_to_list_like(
    values: Scalar | Iterable | AnyArrayLike,
) -> list | AnyArrayLike: ...
@contextlib.contextmanager
def temp_setattr(obj, attr: str, value) -> Iterator[None]: ...
def require_length_match(data, index: Index): ...

_builtin_table = ...
_cython_table = ...

def get_cython_func(arg: Callable) -> str | None: ...
