import ast
from typing import Callable

from pandas.compat import PY39
from pandas.core.computation.ops import Term
from pandas.core.computation.scope import Scope

"""
:func:`~pandas.eval` parsers.
"""
_is_list = ...
_is_str = ...
_all_nodes = ...
_all_node_names = ...
_mod_nodes = ...
_stmt_nodes = ...
_expr_nodes = ...
_expr_context_nodes = ...
_boolop_nodes = ...
_operator_nodes = ...
_unary_op_nodes = ...
_cmp_op_nodes = ...
_comprehension_nodes = ...
_handler_nodes = ...
_arguments_nodes = ...
_keyword_nodes = ...
_alias_nodes = ...
if notPY39:
    _slice_nodes = ...
_hacked_nodes = ...
_unsupported_expr_nodes = ...
_unsupported_nodes = ...
_base_supported_nodes = ...
intersection = ...
_msg = ...
_T = ...

def disallow(nodes: set[str]) -> Callable[[type[_T]], type[_T]]:
    """
    Decorator to disallow certain nodes from parsing. Raises a
    NotImplementedError instead.

    Returns
    -------
    callable
    """
    ...

_op_classes = ...

def add_ops(op_classes):  # -> (cls: Unknown) -> Unknown:
    """
    Decorator to add default implementation of ops.
    """
    ...

@disallow(_unsupported_nodes)
@add_ops(_op_classes)
class BaseExprVisitor(ast.NodeVisitor):
    """
    Custom ast walker. Parsers of other engines should subclass this class
    if necessary.

    Parameters
    ----------
    env : Scope
    engine : str
    parser : str
    preparser : callable
    """

    const_type: type[Term] = ...
    term_type = Term
    binary_ops = ...
    binary_op_nodes = ...
    binary_op_nodes_map = ...
    unary_ops = ...
    unary_op_nodes = ...
    unary_op_nodes_map = ...
    rewrite_map = ...
    unsupported_nodes: tuple[str, ...]
    def __init__(self, env, engine, parser, preparser=...) -> None: ...
    def visit(self, node, **kwargs): ...
    def visit_Module(self, node, **kwargs): ...
    def visit_Expr(self, node, **kwargs): ...
    def visit_BinOp(self, node, **kwargs): ...
    def visit_Div(self, node, **kwargs): ...
    def visit_UnaryOp(self, node, **kwargs): ...
    def visit_Name(self, node, **kwargs): ...
    def visit_NameConstant(self, node, **kwargs): ...
    def visit_Num(self, node, **kwargs): ...
    def visit_Constant(self, node, **kwargs): ...
    def visit_Str(self, node, **kwargs): ...
    def visit_List(self, node, **kwargs): ...
    visit_Tuple = ...
    def visit_Index(self, node, **kwargs):  # -> Any:
        """df.index[4]"""
        ...
    def visit_Subscript(self, node, **kwargs): ...
    def visit_Slice(self, node, **kwargs):  # -> slice:
        """df.index[slice(4,6)]"""
        ...
    def visit_Assign(self, node, **kwargs):  # -> Any:
        """
        support a single assignment node, like

        c = a + b

        set the assigner at the top level, must be a Name node which
        might or might not exist in the resolvers

        """
        ...
    def visit_Attribute(self, node, **kwargs): ...
    def visit_Call(self, node, side=..., **kwargs): ...
    def translate_In(self, op): ...
    def visit_Compare(self, node, **kwargs): ...
    def visit_BoolOp(self, node, **kwargs): ...

_python_not_supported = ...
_numexpr_supported_calls = ...

@disallow(
    (_unsupported_nodes | _python_not_supported)
    - (_boolop_nodes | frozenset(["BoolOp", "Attribute", "In", "NotIn", "Tuple"]))
)
class PandasExprVisitor(BaseExprVisitor):
    def __init__(self, env, engine, parser, preparser=...) -> None: ...

@disallow(_unsupported_nodes | _python_not_supported | frozenset(["Not"]))
class PythonExprVisitor(BaseExprVisitor):
    def __init__(self, env, engine, parser, preparser=...) -> None: ...

class Expr:
    """
    Object encapsulating an expression.

    Parameters
    ----------
    expr : str
    engine : str, optional, default 'numexpr'
    parser : str, optional, default 'pandas'
    env : Scope, optional, default None
    level : int, optional, default 2
    """

    env: Scope
    engine: str
    parser: str
    def __init__(
        self,
        expr,
        engine: str = ...,
        parser: str = ...,
        env: Scope | None = ...,
        level: int = ...,
    ) -> None: ...
    @property
    def assigner(self): ...
    def __call__(self): ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def parse(self):  # -> Any:
        """
        Parse an expression.
        """
        ...
    @property
    def names(self):  # -> frozenset[Any] | frozenset[Unknown]:
        """
        Get the names in an expression.
        """
        ...

PARSERS = ...
