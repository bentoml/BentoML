import os
from abc import ABC
from typing import Callable, Dict, List, Optional, Tuple, Union

def print_evaluation(period=..., show_stdv=...): ...
def record_evaluation(eval_result): ...
def reset_learning_rate(learning_rates): ...
def early_stop(stopping_rounds, maximize=..., verbose=...): ...

class TrainingCallback(ABC):
    EvalsLog = Dict[str, Dict[str, Union[List[float], List[Tuple[float, float]]]]]
    def __init__(self) -> None: ...
    def before_training(self, model): ...
    def after_training(self, model): ...
    def before_iteration(self, model, epoch: int, evals_log: EvalsLog) -> bool: ...
    def after_iteration(self, model, epoch: int, evals_log: EvalsLog) -> bool: ...

class CallbackContainer:
    EvalsLog = TrainingCallback.EvalsLog
    def __init__(
        self,
        callbacks: List[TrainingCallback],
        metric: Callable = ...,
        is_cv: bool = ...,
    ) -> None: ...
    def before_training(self, model): ...
    def after_training(self, model): ...
    def before_iteration(self, model, epoch, dtrain, evals) -> bool: ...
    def after_iteration(self, model, epoch, dtrain, evals) -> bool: ...

class LearningRateScheduler(TrainingCallback):
    def __init__(self, learning_rates) -> None: ...
    def after_iteration(self, model, epoch, evals_log) -> bool: ...

class EarlyStopping(TrainingCallback):
    def __init__(
        self,
        rounds: int,
        metric_name: Optional[str] = ...,
        data_name: Optional[str] = ...,
        maximize: Optional[bool] = ...,
        save_best: Optional[bool] = ...,
        min_delta: float = ...,
    ) -> None: ...
    def before_training(self, model): ...
    def after_iteration(
        self, model, epoch: int, evals_log: TrainingCallback.EvalsLog
    ) -> bool: ...
    def after_training(self, model): ...

class EvaluationMonitor(TrainingCallback):
    def __init__(self, rank=..., period=..., show_stdv=...) -> None: ...
    def after_iteration(
        self, model, epoch: int, evals_log: TrainingCallback.EvalsLog
    ) -> bool: ...
    def after_training(self, model): ...

class TrainingCheckPoint(TrainingCallback):
    def __init__(
        self,
        directory: os.PathLike,
        name: str = ...,
        as_pickle=...,
        iterations: int = ...,
    ) -> None: ...
    def after_iteration(
        self, model, epoch: int, evals_log: TrainingCallback.EvalsLog
    ) -> bool: ...

class LegacyCallbacks:
    def __init__(
        self, callbacks, start_iteration, end_iteration, feval, cvfolds=...
    ) -> None: ...
    def before_training(self, model): ...
    def after_training(self, model): ...
    def before_iteration(self, model, epoch, dtrain, evals): ...
    def after_iteration(self, model, epoch, dtrain, evals): ...
