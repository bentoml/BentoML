import sys
from typing import Any, Callable, Dict, Literal, Optional, Tuple, Type, Union, overload

from numpy import (
    bool_,
    dtype,
    float32,
    float64,
    int8,
    int16,
    int32,
    int64,
    int_,
    ndarray,
    uint,
    uint8,
    uint16,
    uint32,
    uint64,
)
from numpy.random.bit_generator import BitGenerator
from numpy.typing import (
    ArrayLike,
    _ArrayLikeFloat_co,
    _ArrayLikeInt_co,
    _DoubleCodes,
    _DTypeLikeBool,
    _DTypeLikeInt,
    _DTypeLikeUInt,
    _Float32Codes,
    _Float64Codes,
    _Int8Codes,
    _Int16Codes,
    _Int32Codes,
    _Int64Codes,
    _IntCodes,
    _ShapeLike,
    _SingleCodes,
    _SupportsDType,
    _UInt8Codes,
    _UInt16Codes,
    _UInt32Codes,
    _UInt64Codes,
    _UIntCodes,
)

if sys.version_info >= (3, 8): ...
else: ...
_DTypeLikeFloat32 = (
    Union[
        dtype[float32],
        _SupportsDType[dtype[float32]],
        Type[float32],
        _Float32Codes,
        _SingleCodes,
    ],
)
_DTypeLikeFloat64 = (
    Union[
        dtype[float64],
        _SupportsDType[dtype[float64]],
        Type[float],
        Type[float64],
        _Float64Codes,
        _DoubleCodes,
    ],
)

class RandomState:
    _bit_generator: BitGenerator
    def __init__(
        self, seed: Union[None, _ArrayLikeInt_co, BitGenerator] = ...
    ) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, state: Dict[str, Any]) -> None: ...
    def __reduce__(
        self,
    ) -> Tuple[Callable[[str], RandomState], Tuple[str], Dict[str, Any]]: ...
    def seed(self, seed: Optional[_ArrayLikeFloat_co] = ...) -> None: ...
    @overload
    def get_state(self, legacy: Literal[False] = ...) -> Dict[str, Any]: ...
    @overload
    def get_state(
        self, legacy: Literal[True] = ...
    ) -> Union[
        Dict[str, Any], Tuple[str, ndarray[Any, dtype[uint32]], int, int, float]
    ]: ...
    def set_state(
        self,
        state: Union[
            Dict[str, Any], Tuple[str, ndarray[Any, dtype[uint32]], int, int, float]
        ],
    ) -> None: ...
    @overload
    def random_sample(self, size: None = ...) -> float: ...
    @overload
    def random_sample(self, size: _ShapeLike = ...) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def random(self, size: None = ...) -> float: ...
    @overload
    def random(self, size: _ShapeLike = ...) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def beta(self, a: float, b: float, size: None = ...) -> float: ...
    @overload
    def beta(
        self,
        a: _ArrayLikeFloat_co,
        b: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def exponential(self, scale: float = ..., size: None = ...) -> float: ...
    @overload
    def exponential(
        self, scale: _ArrayLikeFloat_co = ..., size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def standard_exponential(self, size: None = ...) -> float: ...
    @overload
    def standard_exponential(
        self, size: _ShapeLike = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def tomaxint(self, size: None = ...) -> int: ...
    @overload
    def tomaxint(self, size: _ShapeLike = ...) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def randint(self, low: int, high: Optional[int] = ...) -> int: ...
    @overload
    def randint(
        self,
        low: int,
        high: Optional[int] = ...,
        size: None = ...,
        dtype: _DTypeLikeBool = ...,
    ) -> bool: ...
    @overload
    def randint(
        self,
        low: int,
        high: Optional[int] = ...,
        size: None = ...,
        dtype: Union[_DTypeLikeInt, _DTypeLikeUInt] = ...,
    ) -> int: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: _DTypeLikeBool = ...,
    ) -> ndarray[Any, dtype[bool_]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[int8], Type[int8], _Int8Codes, _SupportsDType[dtype[int8]]
        ] = ...,
    ) -> ndarray[Any, dtype[int8]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[int16], Type[int16], _Int16Codes, _SupportsDType[dtype[int16]]
        ] = ...,
    ) -> ndarray[Any, dtype[int16]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[int32], Type[int32], _Int32Codes, _SupportsDType[dtype[int32]]
        ] = ...,
    ) -> ndarray[Any, dtype[Union[int32]]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Optional[
            Union[dtype[int64], Type[int64], _Int64Codes, _SupportsDType[dtype[int64]]]
        ] = ...,
    ) -> ndarray[Any, dtype[int64]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[uint8], Type[uint8], _UInt8Codes, _SupportsDType[dtype[uint8]]
        ] = ...,
    ) -> ndarray[Any, dtype[uint8]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[uint16], Type[uint16], _UInt16Codes, _SupportsDType[dtype[uint16]]
        ] = ...,
    ) -> ndarray[Any, dtype[Union[uint16]]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[uint32], Type[uint32], _UInt32Codes, _SupportsDType[dtype[uint32]]
        ] = ...,
    ) -> ndarray[Any, dtype[uint32]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[uint64], Type[uint64], _UInt64Codes, _SupportsDType[dtype[uint64]]
        ] = ...,
    ) -> ndarray[Any, dtype[uint64]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[int_], Type[int], Type[int_], _IntCodes, _SupportsDType[dtype[int_]]
        ] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def randint(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
        dtype: Union[
            dtype[uint], Type[uint], _UIntCodes, _SupportsDType[dtype[uint]]
        ] = ...,
    ) -> ndarray[Any, dtype[uint]]: ...
    def bytes(self, length: int) -> bytes: ...
    @overload
    def choice(
        self,
        a: int,
        size: None = ...,
        replace: bool = ...,
        p: Optional[_ArrayLikeFloat_co] = ...,
    ) -> int: ...
    @overload
    def choice(
        self,
        a: int,
        size: _ShapeLike = ...,
        replace: bool = ...,
        p: Optional[_ArrayLikeFloat_co] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def choice(
        self,
        a: ArrayLike,
        size: None = ...,
        replace: bool = ...,
        p: Optional[_ArrayLikeFloat_co] = ...,
    ) -> Any: ...
    @overload
    def choice(
        self,
        a: ArrayLike,
        size: _ShapeLike = ...,
        replace: bool = ...,
        p: Optional[_ArrayLikeFloat_co] = ...,
    ) -> ndarray[Any, Any]: ...
    @overload
    def uniform(self, low: float = ..., high: float = ..., size: None = ...) -> float: ...
    @overload
    def uniform(
        self,
        low: _ArrayLikeFloat_co = ...,
        high: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def rand(self) -> float: ...
    @overload
    def rand(self, *args: int) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def randn(self) -> float: ...
    @overload
    def randn(self, *args: int) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def random_integers(
        self, low: int, high: Optional[int] = ..., size: None = ...
    ) -> int: ...
    @overload
    def random_integers(
        self,
        low: _ArrayLikeInt_co,
        high: Optional[_ArrayLikeInt_co] = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def standard_normal(self, size: None = ...) -> float: ...
    @overload
    def standard_normal(self, size: _ShapeLike = ...) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def normal(self, loc: float = ..., scale: float = ..., size: None = ...) -> float: ...
    @overload
    def normal(
        self,
        loc: _ArrayLikeFloat_co = ...,
        scale: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def standard_gamma(self, shape: float, size: None = ...) -> float: ...
    @overload
    def standard_gamma(
        self, shape: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def gamma(self, shape: float, scale: float = ..., size: None = ...) -> float: ...
    @overload
    def gamma(
        self,
        shape: _ArrayLikeFloat_co,
        scale: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def f(self, dfnum: float, dfden: float, size: None = ...) -> float: ...
    @overload
    def f(
        self,
        dfnum: _ArrayLikeFloat_co,
        dfden: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def noncentral_f(
        self, dfnum: float, dfden: float, nonc: float, size: None = ...
    ) -> float: ...
    @overload
    def noncentral_f(
        self,
        dfnum: _ArrayLikeFloat_co,
        dfden: _ArrayLikeFloat_co,
        nonc: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def chisquare(self, df: float, size: None = ...) -> float: ...
    @overload
    def chisquare(
        self, df: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def noncentral_chisquare(self, df: float, nonc: float, size: None = ...) -> float: ...
    @overload
    def noncentral_chisquare(
        self,
        df: _ArrayLikeFloat_co,
        nonc: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def standard_t(self, df: float, size: None = ...) -> float: ...
    @overload
    def standard_t(
        self, df: _ArrayLikeFloat_co, size: None = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def standard_t(
        self, df: _ArrayLikeFloat_co, size: _ShapeLike = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def vonmises(self, mu: float, kappa: float, size: None = ...) -> float: ...
    @overload
    def vonmises(
        self,
        mu: _ArrayLikeFloat_co,
        kappa: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def pareto(self, a: float, size: None = ...) -> float: ...
    @overload
    def pareto(
        self, a: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def weibull(self, a: float, size: None = ...) -> float: ...
    @overload
    def weibull(
        self, a: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def power(self, a: float, size: None = ...) -> float: ...
    @overload
    def power(
        self, a: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def standard_cauchy(self, size: None = ...) -> float: ...
    @overload
    def standard_cauchy(self, size: _ShapeLike = ...) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def laplace(
        self, loc: float = ..., scale: float = ..., size: None = ...
    ) -> float: ...
    @overload
    def laplace(
        self,
        loc: _ArrayLikeFloat_co = ...,
        scale: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def gumbel(self, loc: float = ..., scale: float = ..., size: None = ...) -> float: ...
    @overload
    def gumbel(
        self,
        loc: _ArrayLikeFloat_co = ...,
        scale: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def logistic(
        self, loc: float = ..., scale: float = ..., size: None = ...
    ) -> float: ...
    @overload
    def logistic(
        self,
        loc: _ArrayLikeFloat_co = ...,
        scale: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def lognormal(
        self, mean: float = ..., sigma: float = ..., size: None = ...
    ) -> float: ...
    @overload
    def lognormal(
        self,
        mean: _ArrayLikeFloat_co = ...,
        sigma: _ArrayLikeFloat_co = ...,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def rayleigh(self, scale: float = ..., size: None = ...) -> float: ...
    @overload
    def rayleigh(
        self, scale: _ArrayLikeFloat_co = ..., size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def wald(self, mean: float, scale: float, size: None = ...) -> float: ...
    @overload
    def wald(
        self,
        mean: _ArrayLikeFloat_co,
        scale: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def triangular(
        self, left: float, mode: float, right: float, size: None = ...
    ) -> float: ...
    @overload
    def triangular(
        self,
        left: _ArrayLikeFloat_co,
        mode: _ArrayLikeFloat_co,
        right: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    @overload
    def binomial(self, n: int, p: float, size: None = ...) -> int: ...
    @overload
    def binomial(
        self, n: _ArrayLikeInt_co, p: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def negative_binomial(self, n: float, p: float, size: None = ...) -> int: ...
    @overload
    def negative_binomial(
        self,
        n: _ArrayLikeFloat_co,
        p: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def poisson(self, lam: float = ..., size: None = ...) -> int: ...
    @overload
    def poisson(
        self, lam: _ArrayLikeFloat_co = ..., size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def zipf(self, a: float, size: None = ...) -> int: ...
    @overload
    def zipf(
        self, a: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def geometric(self, p: float, size: None = ...) -> int: ...
    @overload
    def geometric(
        self, p: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def hypergeometric(
        self, ngood: int, nbad: int, nsample: int, size: None = ...
    ) -> int: ...
    @overload
    def hypergeometric(
        self,
        ngood: _ArrayLikeInt_co,
        nbad: _ArrayLikeInt_co,
        nsample: _ArrayLikeInt_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def logseries(self, p: float, size: None = ...) -> int: ...
    @overload
    def logseries(
        self, p: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[int_]]: ...
    def multivariate_normal(
        self,
        mean: _ArrayLikeFloat_co,
        cov: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
        check_valid: Literal["warn", "raise", "ignore"] = ...,
        tol: float = ...,
    ) -> ndarray[Any, dtype[float64]]: ...
    def multinomial(
        self,
        n: _ArrayLikeInt_co,
        pvals: _ArrayLikeFloat_co,
        size: Optional[_ShapeLike] = ...,
    ) -> ndarray[Any, dtype[int_]]: ...
    def dirichlet(
        self, alpha: _ArrayLikeFloat_co, size: Optional[_ShapeLike] = ...
    ) -> ndarray[Any, dtype[float64]]: ...
    def shuffle(self, x: ArrayLike) -> None: ...
    @overload
    def permutation(self, x: int) -> ndarray[Any, dtype[int_]]: ...
    @overload
    def permutation(self, x: ArrayLike) -> ndarray[Any, Any]: ...

_rand: RandomState
beta = ...
binomial = ...
bytes = ...
chisquare = ...
choice = ...
dirichlet = ...
exponential = ...
f = ...
gamma = ...
get_state = ...
geometric = ...
gumbel = ...
hypergeometric = ...
laplace = ...
logistic = ...
lognormal = ...
logseries = ...
multinomial = ...
multivariate_normal = ...
negative_binomial = ...
noncentral_chisquare = ...
noncentral_f = ...
normal = ...
pareto = ...
permutation = ...
poisson = ...
power = ...
rand = ...
randint = ...
randn = ...
random = ...
random_integers = ...
random_sample = ...
rayleigh = ...
seed = ...
set_state = ...
shuffle = ...
standard_cauchy = ...
standard_exponential = ...
standard_gamma = ...
standard_normal = ...
standard_t = ...
triangular = ...
uniform = ...
vonmises = ...
wald = ...
weibull = ...
zipf = ...
sample = ...
ranf = ...
