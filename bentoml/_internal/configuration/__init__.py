from __future__ import annotations

import os
import re
import typing as t
import logging
from functools import lru_cache

from bentoml.exceptions import BentoMLException

try:
    import importlib.metadata as importlib_metadata
except ModuleNotFoundError:
    import importlib_metadata

# Note this file is loaded prior to logging being configured, thus logger is only
# used within functions in this file
logger = logging.getLogger(__name__)

DEBUG_ENV_VAR = "BENTOML_DEBUG"
QUIET_ENV_VAR = "BENTOML_QUIET"
CONFIG_ENV_VAR = "BENTOML_CONFIG"


def expand_env_var(env_var: str) -> str:
    """Expands potentially nested env var by repeatedly applying `expandvars` and
    `expanduser` until interpolation stops having any effect.
    """
    while True:
        interpolated = os.path.expanduser(os.path.expandvars(str(env_var)))
        if interpolated == env_var:
            return interpolated
        else:
            env_var = interpolated


def clean_bentoml_version(bentoml_version: str) -> str:
    post_version = bentoml_version.split("+")[0]
    match = re.match(r"^(\d+)\.(\d+)\.(\d+)(?:(a|rc)\d)*", post_version)
    if match is None:
        raise BentoMLException("Errors while parsing BentoML version.")
    return match.group()


# Find BentoML version managed by setuptools_scm
BENTOML_VERSION: str = importlib_metadata.version("bentoml")
# Get clean BentoML version indicating latest PyPI release. E.g. 1.0.0.post => 1.0.0
CLEAN_BENTOML_VERSION: str = clean_bentoml_version(BENTOML_VERSION)


@lru_cache(maxsize=1)
def is_pypi_installed_bentoml() -> bool:
    """Returns true if BentoML is installed via PyPI official release or installed from
     source with a release tag, which should come with pre-built docker base image on
     dockerhub.

    BentoML uses setuptools_scm to manage its versions, it looks at three things:

    * the latest tag (with a version number)
    * the distance to this tag (e.g. number of revisions since latest tag)
    * workdir state (e.g. uncommitted changes since latest tag)

    BentoML uses setuptools_scm with `version_scheme = "post-release"` option, which
    uses roughly the following logic to render the version:

    * no distance and clean: {tag}
    * distance and clean: {tag}.post{distance}+{scm letter}{revision hash}
    * no distance and not clean: {tag}+dYYYYMMDD
    * distance and not clean: {tag}.post{distance}+{scm letter}{revision hash}.dYYYYMMDD

    This function looks at the version str and decide if BentoML installation is
    base on a recent official release.
    """
    try:
        from bentoml import _version as version_mod

        is_clean = not str(version_mod.version_tuple[-1]).split(".")[-1].startswith("d")
    except ImportError:
        # Since we aren't VCS _version.py, which is generated by setuptools_scm, assuming it is clean
        # if this file is not found.
        is_clean = True

    # In a git repo with no tag, setuptools_scm generated version starts with "0.1."
    is_tagged = not BENTOML_VERSION.startswith("0.1.")
    not_been_modified = BENTOML_VERSION == BENTOML_VERSION.split("+")[0]
    return is_tagged and is_clean and not_been_modified


def set_debug_mode(enabled: bool) -> None:
    logger.info(
        f"{'Enabling' if enabled else 'Disabling'} debug mode for current BentoML session."
    )
    os.environ[DEBUG_ENV_VAR] = str(enabled)


def get_debug_mode() -> bool:
    return os.environ.get(DEBUG_ENV_VAR, str(False)).lower() == "true"


def set_quiet_mode(enabled: bool) -> None:
    os.environ[DEBUG_ENV_VAR] = str(enabled)


def get_quiet_mode() -> bool:
    return os.environ.get(QUIET_ENV_VAR, str(False)).lower() == "true"


def load_global_config(bentoml_config_file: t.Optional[str] = None):
    """Load global configuration of BentoML"""

    from ..utils import bentoml_cattr
    from .containers import BentoMLContainer
    from .containers import BentoMLConfiguration

    config_from_env_var = os.environ.get(CONFIG_ENV_VAR)
    if not bentoml_config_file and config_from_env_var:
        bentoml_config_file = expand_env_var(config_from_env_var)

    if bentoml_config_file:
        if not bentoml_config_file.endswith((".yml", ".yaml")):
            raise Exception(
                "BentoML config file specified in ENV VAR does not end with `.yaml`: "
                f"`BENTOML_CONFIG={bentoml_config_file}`"
            )
        if not os.path.isfile(bentoml_config_file):
            raise FileNotFoundError(
                "BentoML config file specified in ENV VAR not found: "
                f"`BENTOML_CONFIG={bentoml_config_file}`"
            )

    cls = BentoMLConfiguration(override_config_file=bentoml_config_file)

    BentoMLContainer.config.set(bentoml_cattr.unstructure(cls.config))
