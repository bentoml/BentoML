"""
This type stub file was generated by pyright.
"""

from inspect import Signature
from pathlib import Path
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Generator,
    Iterable,
    Iterator,
    List,
    Optional,
    Set,
    Tuple,
    Type,
    Union,
    no_type_check,
)

from .dataclasses import Dataclass
from .fields import ModelField
from .main import BaseConfig, BaseModel
from .typing import AbstractSetIntStr, IntStr, MappingIntStrAny, ReprArgs

if TYPE_CHECKING: ...
__all__ = (
    "import_string",
    "sequence_like",
    "validate_field_name",
    "lenient_issubclass",
    "in_ipython",
    "deep_update",
    "update_not_none",
    "almost_equal_floats",
    "get_model",
    "to_camel",
    "is_valid_field",
    "smart_deepcopy",
    "PyObjectStr",
    "Representation",
    "GetterDict",
    "ValueItems",
    "version_info",
    "ClassAttribute",
    "path_type",
    "ROOT_KEY",
)
ROOT_KEY = ...
IMMUTABLE_NON_COLLECTIONS_TYPES: Set[Type[Any]] = ...
BUILTIN_COLLECTIONS: Set[Type[Any]] = ...

def import_string(dotted_path: str) -> Any:
    """
    Stolen approximately from django. Import a dotted module path and return the attribute/class designated by the
    last name in the path. Raise ImportError if the import fails.
    """
    ...

def truncate(v: Union[str], *, max_len: int = ...) -> str:
    """
    Truncate a value and add a unicode ellipsis (three dots) to the end if it was too long
    """
    ...

def sequence_like(v: Type[Any]) -> bool: ...
def validate_field_name(bases: List[Type[BaseModel]], field_name: str) -> None:
    """
    Ensure that the field's name does not shadow an existing attribute of the model.
    """
    ...

def lenient_issubclass(
    cls: Any, class_or_tuple: Union[Type[Any], Tuple[Type[Any], ...]]
) -> bool: ...
def in_ipython() -> bool:
    """
    Check whether we're in an ipython environment, including jupyter notebooks.
    """
    ...

KeyType = ...

def deep_update(
    mapping: Dict[KeyType, Any], *updating_mappings: Dict[KeyType, Any]
) -> Dict[KeyType, Any]: ...
def update_not_none(mapping: Dict[Any, Any], **update: Any) -> None: ...
def almost_equal_floats(value_1: float, value_2: float, *, delta: float = ...) -> bool:
    """
    Return True if two floats are almost equal
    """
    ...

def generate_model_signature(
    init: Callable[..., None], fields: Dict[str, ModelField], config: Type[BaseConfig]
) -> Signature:
    """
    Generate signature for model based on its fields
    """
    ...

def get_model(obj: Union[Type[BaseModel], Type[Dataclass]]) -> Type[BaseModel]: ...
def to_camel(string: str) -> str: ...

T = ...

def unique_list(input_list: Union[List[T], Tuple[T, ...]]) -> List[T]:
    """
    Make a list unique while maintaining order.
    """
    ...

def update_normalized_all(
    item: Union[AbstractSetIntStr, MappingIntStrAny],
    all_items: Union[AbstractSetIntStr, MappingIntStrAny],
) -> Union[AbstractSetIntStr, MappingIntStrAny]:
    """
    Update item based on what all items contains.

    The update is done based on these cases:

    - if both arguments are dicts then each key-value pair existing in ``all_items`` is merged into ``item``,
      while the rest of the key-value pairs are updated recursively with this function.
    - if both arguments are sets then they are just merged.
    - if ``item`` is a dictionary and ``all_items`` is a set then all values of it are added to ``item`` as
      ``key: ...``.
    - if ``item`` is set and ``all_items`` is a dictionary, then ``item`` is converted to a dictionary and then the
      key-value pairs of ``all_items`` are merged in it.

    During recursive calls, there is a case where ``all_items`` can be an Ellipsis, in which case the ``item`` is
    returned as is.
    """
    ...

class PyObjectStr(str):
    """
    String class where repr doesn't include quotes. Useful with Representation when you want to return a string
    representation of something that valid (or pseudo-valid) python.
    """

    def __repr__(self) -> str: ...

class Representation:
    """
    Mixin to provide __str__, __repr__, and __pretty__ methods. See #884 for more details.

    __pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations
    of objects.
    """

    __slots__: Tuple[str, ...] = ...
    def __repr_args__(self) -> ReprArgs:
        """
        Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.

        Can either return:
        * name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`
        * or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`
        """
        ...
    def __repr_name__(self) -> str:
        """
        Name of the instance's class, used in __repr__.
        """
        ...
    def __repr_str__(self, join_str: str) -> str: ...
    def __pretty__(
        self, fmt: Callable[[Any], Any], **kwargs: Any
    ) -> Generator[Any, None, None]:
        """
        Used by devtools (https://python-devtools.helpmanual.io/) to provide a human readable representations of objects
        """
        ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class GetterDict(Representation):
    """
    Hack to make object's smell just enough like dicts for validate_model.

    We can't inherit from Mapping[str, Any] because it upsets cython so we have to implement all methods ourselves.
    """

    __slots__ = ...
    def __init__(self, obj: Any) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def get(self, key: Any, default: Any = ...) -> Any: ...
    def extra_keys(self) -> Set[Any]:
        """
        We don't want to get any other attributes of obj if the model didn't explicitly ask for them
        """
        ...
    def keys(self) -> List[Any]:
        """
        Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python
        dictionaries.
        """
        ...
    def values(self) -> List[Any]: ...
    def items(self) -> Iterator[Tuple[str, Any]]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __contains__(self, item: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __repr_args__(self) -> ReprArgs: ...
    def __repr_name__(self) -> str: ...

class ValueItems(Representation):
    """
    Class for more convenient calculation of excluded or included fields on values.
    """

    __slots__ = ...
    def __init__(
        self, value: Any, items: Union[AbstractSetIntStr, MappingIntStrAny]
    ) -> None: ...
    @no_type_check
    def is_excluded(self, item: Any) -> bool:
        """
        Check if item is fully excluded
        (value considered excluded if self._type is set and item contained in self._items
         or self._type is dict and self._items.get(item) is ...

        :param item: key or index of a value
        """
        ...
    @no_type_check
    def is_included(self, item: Any) -> bool:
        """
        Check if value is contained in self._items

        :param item: key or index of value
        """
        ...
    @no_type_check
    def for_element(
        self, e: IntStr
    ) -> Optional[Union[AbstractSetIntStr, MappingIntStrAny]]:
        """
        :param e: key or index of element on value
        :return: raw values for elemet if self._items is dict and contain needed element
        """
        ...
    def __repr_args__(self) -> ReprArgs: ...

class ClassAttribute:
    """
    Hide class attribute from its instances
    """

    __slots__ = ...
    def __init__(self, name: str, value: Any) -> None: ...
    def __get__(self, instance: Any, owner: Type[Any]) -> None: ...

path_types = ...

def path_type(p: Path) -> str:
    """
    Find out what sort of thing a path is.
    """
    ...

Obj = ...

def smart_deepcopy(obj: Obj) -> Obj:
    """
    Return type as is for immutable built-in types
    Use obj.copy() for built-in empty collections
    Use copy.deepcopy() for non-empty collections and unknown objects
    """
    ...

def is_valid_field(name: str) -> bool: ...
def is_valid_private_name(name: str) -> bool: ...

_EMPTY = ...

def all_identical(left: Iterable[Any], right: Iterable[Any]) -> bool:
    """
    Check that the items of `left` are the same objects as those in `right`.

    >>> a, b = object(), object()
    >>> all_identical([a, b, a], [a, b, a])
    True
    >>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while "equal" is not "identical"
    False
    """
    ...
