from datetime import tzinfo
from typing import TYPE_CHECKING, Any, MutableMapping
import numpy as np
import pyarrow
from pandas import Categorical, Index
from pandas._libs.tslibs import Period, Timestamp, dtypes
from pandas._typing import DtypeObj, NpDtype, Ordered, type_t
from pandas.core.arrays import DatetimeArray, IntervalArray, PandasArray, PeriodArray
from pandas.core.dtypes.base import ExtensionDtype, register_extension_dtype

if TYPE_CHECKING: ...
str_type = str

class PandasExtensionDtype(ExtensionDtype):
    type: Any
    kind: Any
    subdtype = ...
    str: str_type
    num = ...
    shape: tuple[int, ...] = ...
    itemsize = ...
    base: DtypeObj | None = ...
    isbuiltin = ...
    isnative = ...
    _cache_dtypes: dict[str_type, PandasExtensionDtype] = ...
    def __repr__(self) -> str_type: ...
    def __hash__(self) -> int: ...
    def __getstate__(self) -> dict[str_type, Any]: ...
    @classmethod
    def reset_cache(cls) -> None: ...

class CategoricalDtypeType(type): ...

@register_extension_dtype
class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
    name = ...
    type: type[CategoricalDtypeType] = ...
    kind: str_type = ...
    str = ...
    base = ...
    _metadata = ...
    _cache_dtypes: dict[str_type, PandasExtensionDtype] = ...
    def __init__(self, categories=..., ordered: Ordered = ...) -> None: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> CategoricalDtype: ...
    def __setstate__(self, state: MutableMapping[str_type, Any]) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __repr__(self) -> str_type: ...
    @classmethod
    def construct_array_type(cls) -> type_t[Categorical]: ...
    @staticmethod
    def validate_ordered(ordered: Ordered) -> None: ...
    @staticmethod
    def validate_categories(categories, fastpath: bool = ...) -> Index: ...
    def update_dtype(self, dtype: str_type | CategoricalDtype) -> CategoricalDtype: ...
    @property
    def categories(self) -> Index: ...
    @property
    def ordered(self) -> Ordered: ...

@register_extension_dtype
class DatetimeTZDtype(PandasExtensionDtype):
    type: type[Timestamp] = ...
    kind: str_type = ...
    str = ...
    num = ...
    base = ...
    na_value = ...
    _metadata = ...
    _match = ...
    _cache_dtypes: dict[str_type, PandasExtensionDtype] = ...
    def __init__(self, unit: str_type | DatetimeTZDtype = ..., tz=...) -> None: ...
    @property
    def unit(self) -> str_type: ...
    @property
    def tz(self) -> tzinfo: ...
    @classmethod
    def construct_array_type(cls) -> type_t[DatetimeArray]: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> DatetimeTZDtype: ...
    def __str__(self) -> str_type: ...
    @property
    def name(self) -> str_type: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __setstate__(self, state) -> None: ...

@register_extension_dtype
class PeriodDtype(dtypes.PeriodDtypeBase, PandasExtensionDtype):
    type: type[Period] = ...
    kind: str_type = ...
    str = ...
    base = ...
    num = ...
    _metadata = ...
    _match = ...
    _cache_dtypes: dict[str_type, PandasExtensionDtype] = ...
    def __new__(cls, freq=...): ...
    def __reduce__(self): ...
    @property
    def freq(self): ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> PeriodDtype: ...
    def __str__(self) -> str_type: ...
    @property
    def name(self) -> str_type: ...
    @property
    def na_value(self): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __setstate__(self, state): ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...
    @classmethod
    def construct_array_type(cls) -> type_t[PeriodArray]: ...
    def __from_arrow__(
        self, array: pyarrow.Array | pyarrow.ChunkedArray
    ) -> PeriodArray: ...

@register_extension_dtype
class IntervalDtype(PandasExtensionDtype):
    name = ...
    kind: str_type = ...
    str = ...
    base = ...
    num = ...
    _metadata = ...
    _match = ...
    _cache_dtypes: dict[str_type, PandasExtensionDtype] = ...
    def __new__(cls, subtype=..., closed: str_type | None = ...): ...
    @property
    def closed(self): ...
    @property
    def subtype(self): ...
    @classmethod
    def construct_array_type(cls) -> type[IntervalArray]: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> IntervalDtype: ...
    @property
    def type(self): ...
    def __str__(self) -> str_type: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __setstate__(self, state): ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...
    def __from_arrow__(
        self, array: pyarrow.Array | pyarrow.ChunkedArray
    ) -> IntervalArray: ...

class PandasDtype(ExtensionDtype):
    _metadata = ...
    def __init__(self, dtype: NpDtype | PandasDtype | None) -> None: ...
    def __repr__(self) -> str: ...
    @property
    def numpy_dtype(self) -> np.dtype: ...
    @property
    def name(self) -> str: ...
    @property
    def type(self) -> type[np.generic]: ...
    @classmethod
    def construct_from_string(cls, string: str) -> PandasDtype: ...
    @classmethod
    def construct_array_type(cls) -> type_t[PandasArray]: ...
    @property
    def kind(self) -> str: ...
    @property
    def itemsize(self) -> int: ...
