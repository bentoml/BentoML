"""
This type stub file was generated by pyright.
"""

from collections import OrderedDict
from collections.abc import Hashable
from decimal import Decimal
from enum import Enum, IntEnum
from ipaddress import (IPv4Address, IPv4Interface, IPv4Network, IPv6Address,
                       IPv6Interface, IPv6Network)
from pathlib import Path
from typing import (TYPE_CHECKING, Any, Callable, Deque, Dict, FrozenSet,
                    Generator, List, Pattern, Set, Tuple, Type, Union)
from uuid import UUID

from typing_extensions import Literal

from .annotated_types import TypedDict
from .fields import ModelField
from .main import BaseConfig
from .types import ConstrainedDecimal, ConstrainedFloat, ConstrainedInt
from .typing import AnyCallable

if TYPE_CHECKING:
    ConstrainedNumber = Union[ConstrainedDecimal, ConstrainedFloat, ConstrainedInt]
    AnyOrderedDict = OrderedDict[Any, Any]
    Number = Union[int, float, Decimal]
    StrBytes = Union[str, bytes]

def str_validator(v: Any) -> Union[str]: ...
def strict_str_validator(v: Any) -> Union[str]: ...
def bytes_validator(v: Any) -> bytes: ...
def strict_bytes_validator(v: Any) -> Union[bytes]: ...

BOOL_FALSE = ...
BOOL_TRUE = ...

def bool_validator(v: Any) -> bool: ...
def int_validator(v: Any) -> int: ...
def strict_int_validator(v: Any) -> int: ...
def float_validator(v: Any) -> float: ...
def strict_float_validator(v: Any) -> float: ...
def number_multiple_validator(v: Number, field: ModelField) -> Number: ...
def number_size_validator(v: Number, field: ModelField) -> Number: ...
def constant_validator(v: Any, field: ModelField) -> Any:
    """Validate ``const`` fields.

    The value provided for a ``const`` field must be equal to the default value
    of the field. This is to support the keyword of the same name in JSON
    Schema.
    """
    ...

def anystr_length_validator(v: StrBytes, config: BaseConfig) -> StrBytes: ...
def anystr_strip_whitespace(v: StrBytes) -> StrBytes: ...
def anystr_lower(v: StrBytes) -> StrBytes: ...
def ordered_dict_validator(v: Any) -> AnyOrderedDict: ...
def dict_validator(v: Any) -> Dict[Any, Any]: ...
def list_validator(v: Any) -> List[Any]: ...
def tuple_validator(v: Any) -> Tuple[Any, ...]: ...
def set_validator(v: Any) -> Set[Any]: ...
def frozenset_validator(v: Any) -> FrozenSet[Any]: ...
def deque_validator(v: Any) -> Deque[Any]: ...
def enum_member_validator(v: Any, field: ModelField, config: BaseConfig) -> Enum: ...
def uuid_validator(v: Any, field: ModelField) -> UUID: ...
def decimal_validator(v: Any) -> Decimal: ...
def hashable_validator(v: Any) -> Hashable: ...
def ip_v4_address_validator(v: Any) -> IPv4Address: ...
def ip_v6_address_validator(v: Any) -> IPv6Address: ...
def ip_v4_network_validator(v: Any) -> IPv4Network:
    """
    Assume IPv4Network initialised with a default ``strict`` argument

    See more:
    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
    """
    ...

def ip_v6_network_validator(v: Any) -> IPv6Network:
    """
    Assume IPv6Network initialised with a default ``strict`` argument

    See more:
    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
    """
    ...

def ip_v4_interface_validator(v: Any) -> IPv4Interface: ...
def ip_v6_interface_validator(v: Any) -> IPv6Interface: ...
def path_validator(v: Any) -> Path: ...
def path_exists_validator(v: Any) -> Path: ...
def callable_validator(v: Any) -> AnyCallable:
    """
    Perform a simple check if the value is callable.

    Note: complete matching of argument type hints and return types is not performed
    """
    ...

def enum_validator(v: Any) -> Enum: ...
def int_enum_validator(v: Any) -> IntEnum: ...
def make_literal_validator(type_: Any) -> Callable[[Any], Any]: ...
def constr_length_validator(
    v: StrBytes, field: ModelField, config: BaseConfig
) -> StrBytes: ...
def constr_strip_whitespace(
    v: StrBytes, field: ModelField, config: BaseConfig
) -> StrBytes: ...
def constr_lower(v: StrBytes, field: ModelField, config: BaseConfig) -> StrBytes: ...
def validate_json(v: Any, config: BaseConfig) -> Any: ...

T = ...

def make_arbitrary_type_validator(type_: Type[T]) -> Callable[[T], T]: ...
def make_class_validator(type_: Type[T]) -> Callable[[Any], Type[T]]: ...
def any_class_validator(v: Any) -> Type[T]: ...
def none_validator(v: Any) -> Literal[None]: ...
def pattern_validator(v: Any) -> Pattern[str]: ...

NamedTupleT = ...

def make_namedtuple_validator(
    namedtuple_cls: Type[NamedTupleT],
) -> Callable[[Tuple[Any, ...]], NamedTupleT]: ...
def make_typeddict_validator(
    typeddict_cls: Type[TypedDict], config: Type[BaseConfig]
) -> Callable[[Any], Dict[str, Any]]: ...

class IfConfig:
    def __init__(self, validator: AnyCallable, *config_attr_names: str) -> None: ...
    def check(self, config: Type[BaseConfig]) -> bool: ...

_VALIDATORS: List[Tuple[Type[Any], List[Any]]] = ...

def find_validators(
    type_: Type[Any], config: Type[BaseConfig]
) -> Generator[AnyCallable, None, None]: ...
