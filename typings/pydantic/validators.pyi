"""
This type stub file was generated by pyright.
"""

from collections import OrderedDict
from collections.abc import Hashable
from decimal import Decimal
from enum import Enum, IntEnum
from ipaddress import (
    IPv4Address,
    IPv4Interface,
    IPv4Network,
    IPv6Address,
    IPv6Interface,
    IPv6Network,
)
from pathlib import Path
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Deque,
    Dict,
    FrozenSet,
    Generator,
    List,
    Pattern,
    Set,
    Tuple,
    Type,
    Union,
)
from uuid import UUID

from typing_extensions import Literal

from .annotated_types import TypedDict
from .fields import ModelField
from .main import BaseConfig
from .types import ConstrainedDecimal, ConstrainedFloat, ConstrainedInt
from .typing import AnyCallable

if TYPE_CHECKING:
    ConstrainedNumber = Union[ConstrainedDecimal, ConstrainedFloat, ConstrainedInt]
    AnyOrderedDict = OrderedDict[Any, Any]
    Number = Union[int, float, Decimal]
    StrBytes = Union[str, bytes]

def str_validator(v: Any) -> Union[str]: ...
def strict_str_validator(v: Any) -> Union[str]: ...
def bytes_validator(v: Any) -> bytes: ...
def strict_bytes_validator(v: Any) -> Union[bytes]: ...

BOOL_FALSE = ...
BOOL_TRUE = ...

def bool_validator(v: Any) -> bool: ...
def int_validator(v: Any) -> int: ...
def strict_int_validator(v: Any) -> int: ...
def float_validator(v: Any) -> float: ...
def strict_float_validator(v: Any) -> float: ...
def number_multiple_validator(v: Number, field: ModelField) -> Number: ...
def number_size_validator(v: Number, field: ModelField) -> Number: ...
def constant_validator(v: Any, field: ModelField) -> Any:
    """Validate ``const`` fields.

    The value provided for a ``const`` field must be equal to the default value
    of the field. This is to support the keyword of the same name in JSON
    Schema.
    """
    ...

def anystr_length_validator(v: StrBytes, config: BaseConfig) -> StrBytes: ...
def anystr_strip_whitespace(v: StrBytes) -> StrBytes: ...
def anystr_lower(v: StrBytes) -> StrBytes: ...
def ordered_dict_validator(v: Any) -> AnyOrderedDict: ...
def dict_validator(v: Any) -> Dict[Any, Any]: ...
def list_validator(v: Any) -> List[Any]: ...
def tuple_validator(v: Any) -> Tuple[Any, ...]: ...
def set_validator(v: Any) -> Set[Any]: ...
def frozenset_validator(v: Any) -> FrozenSet[Any]: ...
def deque_validator(v: Any) -> Deque[Any]: ...
def enum_member_validator(v: Any, field: ModelField, config: BaseConfig) -> Enum: ...
def uuid_validator(v: Any, field: ModelField) -> UUID: ...
def decimal_validator(v: Any) -> Decimal: ...
def hashable_validator(v: Any) -> Hashable: ...
def ip_v4_address_validator(v: Any) -> IPv4Address: ...
def ip_v6_address_validator(v: Any) -> IPv6Address: ...
def ip_v4_network_validator(v: Any) -> IPv4Network:
    """
    Assume IPv4Network initialised with a default ``strict`` argument

    See more:
    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
    """
    ...

def ip_v6_network_validator(v: Any) -> IPv6Network:
    """
    Assume IPv6Network initialised with a default ``strict`` argument

    See more:
    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
    """
    ...

def ip_v4_interface_validator(v: Any) -> IPv4Interface: ...
def ip_v6_interface_validator(v: Any) -> IPv6Interface: ...
def path_validator(v: Any) -> Path: ...
def path_exists_validator(v: Any) -> Path: ...
def callable_validator(v: Any) -> AnyCallable:
    """
    Perform a simple check if the value is callable.

    Note: complete matching of argument type hints and return types is not performed
    """
    ...

def enum_validator(v: Any) -> Enum: ...
def int_enum_validator(v: Any) -> IntEnum: ...
def make_literal_validator(type_: Any) -> Callable[[Any], Any]: ...
def constr_length_validator(
    v: StrBytes, field: ModelField, config: BaseConfig
) -> StrBytes: ...
def constr_strip_whitespace(
    v: StrBytes, field: ModelField, config: BaseConfig
) -> StrBytes: ...
def constr_lower(v: StrBytes, field: ModelField, config: BaseConfig) -> StrBytes: ...
def validate_json(v: Any, config: BaseConfig) -> Any: ...

T = ...

def make_arbitrary_type_validator(type_: Type[T]) -> Callable[[T], T]: ...
def make_class_validator(type_: Type[T]) -> Callable[[Any], Type[T]]: ...
def any_class_validator(v: Any) -> Type[T]: ...
def none_validator(v: Any) -> Literal[None]: ...
def pattern_validator(v: Any) -> Pattern[str]: ...

NamedTupleT = ...

def make_namedtuple_validator(
    namedtuple_cls: Type[NamedTupleT],
) -> Callable[[Tuple[Any, ...]], NamedTupleT]: ...
def make_typeddict_validator(
    typeddict_cls: Type[TypedDict], config: Type[BaseConfig]
) -> Callable[[Any], Dict[str, Any]]: ...

class IfConfig:
    def __init__(self, validator: AnyCallable, *config_attr_names: str) -> None: ...
    def check(self, config: Type[BaseConfig]) -> bool: ...

_VALIDATORS: List[Tuple[Type[Any], List[Any]]] = ...

def find_validators(
    type_: Type[Any], config: Type[BaseConfig]
) -> Generator[AnyCallable, None, None]: ...
