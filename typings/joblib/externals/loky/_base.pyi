import sys
from concurrent.futures import ALL_COMPLETED, FIRST_COMPLETED, FIRST_EXCEPTION
from concurrent.futures import Future as _BaseFuture
from concurrent.futures._base import (
    CANCELLED,
    CANCELLED_AND_NOTIFIED,
    FINISHED,
    LOGGER,
    PENDING,
    RUNNING,
)

if sys.version_info[:2] >= (3, 3): ...
else:
    FIRST_COMPLETED = ...
    FIRST_EXCEPTION = ...
    ALL_COMPLETED = ...
    _AS_COMPLETED = ...
    PENDING = ...
    RUNNING = ...
    CANCELLED = ...
    CANCELLED_AND_NOTIFIED = ...
    FINISHED = ...
    _FUTURE_STATES = ...
    _STATE_TO_DESCRIPTION_MAP = ...
    LOGGER = ...
    class Error(Exception): ...
    class CancelledError(Error): ...
    class TimeoutError(Error): ...
    class _Waiter:
        def __init__(self) -> None: ...
        def add_result(self, future): ...
        def add_exception(self, future): ...
        def add_cancelled(self, future): ...
    class _AsCompletedWaiter(_Waiter):
        def __init__(self) -> None: ...
        def add_result(self, future): ...
        def add_exception(self, future): ...
        def add_cancelled(self, future): ...
    class _FirstCompletedWaiter(_Waiter):
        def add_result(self, future): ...
        def add_exception(self, future): ...
        def add_cancelled(self, future): ...
    class _AllCompletedWaiter(_Waiter):
        def __init__(self, num_pending_calls, stop_on_exception) -> None: ...
        def add_result(self, future): ...
        def add_exception(self, future): ...
        def add_cancelled(self, future): ...
    class _AcquireFutures:
        def __init__(self, futures) -> None: ...
        def __enter__(self): ...
        def __exit__(self, *args): ...
    def as_completed(fs, timeout=...): ...
    DoneAndNotDoneFutures = ...
    def wait(fs, timeout=..., return_when=...): ...
    class _BaseFuture:
        def __init__(self) -> None: ...
        def __repr__(self): ...
        def cancel(self): ...
        def cancelled(self): ...
        def running(self): ...
        def done(self): ...
        def add_done_callback(self, fn): ...
        def result(self, timeout=...): ...
        def exception(self, timeout=...): ...
        def set_running_or_notify_cancel(self): ...
        def set_result(self, result): ...
        def set_exception(self, exception): ...
    class Executor:
        def submit(self, fn, *args, **kwargs): ...
        def map(self, fn, *iterables, **kwargs): ...
        def shutdown(self, wait=...): ...
        def __enter__(self): ...
        def __exit__(self, exc_type, exc_val, exc_tb): ...

class Future(_BaseFuture): ...
