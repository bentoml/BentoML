import ctypes
import os
from types import MappingProxyType
from typing import (
    Any,
    ByteString,
    Callable,
    Dict,
    List,
    Mapping,
    Optional,
    Tuple,
    Union,
)
import numpy as np
import pandas as pd
from scipy import sparse

AnyNdarray = np.ndarray[Any, np.dtype[Any]]
c_bst_ulong = ctypes.c_uint64

class XGBoostError(ValueError): ...

class EarlyStopException(Exception):
    def __init__(self, best_iteration) -> None: ...

CallbackEnv = ...

def from_pystr_to_cstr(data: Union[str, List[str]]): ...
def from_cstr_to_pystr(data, length) -> List[str]: ...

_LIB = ...

def ctypes2numpy(cptr, length, dtype): ...
def ctypes2cupy(cptr, length, dtype): ...
def ctypes2buffer(cptr, length) -> ByteString: ...
def c_str(string): ...
def c_array(ctype, values): ...

class DataIter:
    def __init__(self) -> None: ...
    @property
    def proxy(self): ...
    def reset_wrapper(self, this): ...
    def next_wrapper(self, this): ...
    def reset(self): ...
    def next(self, input_data): ...

DMatrixDataType = Union[
    os.PathLike[str], str, AnyNdarray, pd.DataFrame, sparse.spmatrix
]

class DMatrix:
    def __init__(
        self,
        data: DMatrixDataType,
        label=...,
        *,
        weight=...,
        base_margin=...,
        missing: Optional[float] = ...,
        silent=...,
        feature_names=...,
        feature_types=...,
        nthread: Optional[int] = ...,
        group=...,
        qid=...,
        label_lower_bound=...,
        label_upper_bound=...,
        feature_weights=...,
        enable_categorical: bool = ...
    ) -> None: ...
    def __del__(self): ...
    def set_info(
        self,
        *,
        label=...,
        weight=...,
        base_margin=...,
        group=...,
        qid=...,
        label_lower_bound=...,
        label_upper_bound=...,
        feature_names=...,
        feature_types=...,
        feature_weights=...
    ) -> None: ...
    def get_float_info(self, field): ...
    def get_uint_info(self, field): ...
    def set_float_info(self, field, data): ...
    def set_float_info_npy2d(self, field, data): ...
    def set_uint_info(self, field, data): ...
    def save_binary(self, fname, silent=...): ...
    def set_label(self, label): ...
    def set_weight(self, weight): ...
    def set_base_margin(self, margin): ...
    def set_group(self, group): ...
    def get_label(self): ...
    def get_weight(self): ...
    def get_base_margin(self): ...
    def num_row(self): ...
    def num_col(self): ...
    def slice(
        self, rindex: Union[List[int], AnyNdarray], allow_groups: bool = ...
    ) -> DMatrix: ...
    @property
    def feature_names(self) -> List[str]: ...
    @feature_names.setter
    def feature_names(self, feature_names: Optional[Union[List[str], str]]) -> None: ...
    @property
    def feature_types(self) -> Optional[List[str]]: ...
    @feature_types.setter
    def feature_types(self, feature_types: Optional[Union[List[Any], Any]]) -> None: ...

class _ProxyDMatrix(DMatrix):
    def __init__(self) -> None: ...

class DeviceQuantileDMatrix(DMatrix):
    @_deprecate_positional_args
    def __init__(
        self,
        data,
        label=...,
        *,
        weight=...,
        base_margin=...,
        missing=...,
        silent=...,
        feature_names=...,
        feature_types=...,
        nthread: Optional[int] = ...,
        max_bin: int = ...,
        group=...,
        qid=...,
        label_lower_bound=...,
        label_upper_bound=...,
        feature_weights=...,
        enable_categorical: bool = ...
    ) -> None: ...

Objective = Callable[[AnyNdarray, DMatrix], Tuple[AnyNdarray, ...]]
Metric = Callable[[AnyNdarray, DMatrix], Tuple[str, float]]

class Booster:
    def __init__(
        self,
        params: Dict[str, Any] = ...,
        cache: List[DMatrix] = ...,
        model_file: Union[str, os.PathLike[str], "Booster", ByteString] = ...,
    ) -> None: ...
    def _configure_metrics(
        self, params: Union[Dict[str, Any], List[str]]
    ) -> Union[Dict[str, Any], List[str]]: ...
    def __del__(self) -> None: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, state: MappingProxyType[str, Any]) -> Dict[str, Any]: ...
    def __getitem__(self, val: Any) -> "Booster": ...
    def save_config(self) -> str: ...
    def load_config(self, config: str) -> None: ...
    def __copy__(self) -> "Booster": ...
    def __deepcopy__(self, _) -> "Booster": ...
    def copy(self) -> "Booster": ...
    def attr(self, key: str) -> Optional[str]: ...
    def attributes(self) -> Dict[str, Optional[str]]: ...
    def set_attr(self, **kwargs: str) -> None: ...
    @property
    def feature_types(self) -> Optional[List[str]]: ...
    @property
    def feature_names(self) -> Optional[List[str]]: ...
    @feature_names.setter
    def feature_names(self, features: Optional[List[str]]) -> None: ...
    @feature_types.setter
    def feature_types(self, features: Optional[List[str]]) -> None: ...
    def set_param(
        self,
        params: Union[Dict[str, Any], List[Mapping[str, str]], str],
        value: Optional[str] = ...,
    ) -> None: ...
    def update(
        self, dtrain: DMatrix, iteration: int, fobj: Callable[..., Any] = ...
    ) -> None: ...
    def boost(self, dtrain: DMatrix, grad: List[Any], hess: List[Any]) -> None: ...
    def eval_set(
        self,
        evals: List[Tuple[DMatrix, str]],
        iteration: int = ...,
        feval: Callable[..., Any] = ...,
    ) -> str: ...
    def eval(self, data: DMatrix, name: str = ..., iteration: int = ...) -> str: ...
    def predict(
        self,
        data: DMatrix,
        output_margin: bool = ...,
        ntree_limit: int = ...,
        pred_leaf: bool = ...,
        pred_contribs: bool = ...,
        approx_contribs: bool = ...,
        pred_interactions: bool = ...,
        validate_features: bool = ...,
        training: bool = ...,
        iteration_range: Tuple[int, int] = ...,
        strict_shape: bool = ...,
    ) -> AnyNdarray: ...
    def inplace_predict(
        self,
        data: Any,
        iteration_range: Tuple[int, int] = ...,
        predict_type: str = ...,
        missing: float = ...,
        validate_features: bool = ...,
        base_margin: Any = ...,
        strict_shape: bool = ...,
    ): ...
    def save_model(self, fname: Union[str, os.PathLike[str]]) -> None: ...
    def save_raw(self) -> ByteString: ...
    def load_model(self, fname: Union[str, os.PathLike[str], ByteString]) -> None: ...
    def num_boosted_rounds(self) -> int: ...
    def num_features(self) -> int: ...
    def dump_model(self, fout, fmap=..., with_stats=..., dump_format=...): ...
    def get_dump(self, fmap=..., with_stats=..., dump_format=...): ...
    def get_fscore(self, fmap=...): ...
    def get_score(self, fmap=..., importance_type=...): ...
    def trees_to_dataframe(self, fmap=...): ...
    def get_split_value_histogram(self, feature, fmap=..., bins=..., as_pandas=...): ...
