"""
This type stub file was generated by pyright.
"""

import os
from tornado import concurrent
from configparser import RawConfigParser

"""
This type stub file was generated by pyright.
"""
DEFAULT_ENDPOINT_DEALER = ...
DEFAULT_ENDPOINT_SUB = ...
DEFAULT_ENDPOINT_STATS = ...
DEFAULT_ENDPOINT_MULTICAST = ...
MAXFD = ...
if hasattr(os, "devnull"):
    REDIRECT_TO = ...
else:
    REDIRECT_TO = ...
LOG_LEVELS = ...
LOG_FMT = ...
LOG_DATE_FMT = ...
LOG_DATE_SYSLOG_FMT = ...
_SYMBOLS = ...
_all_signals = ...
IS_WINDOWS = ...
def get_working_dir():
    """Returns current path, try to use PWD env first.

    Since os.getcwd() resolves symlinks, we want to use
    PWD first if present.
    """
    ...

def bytes2human(n):
    """Translates bytes into a human repr.
    """
    ...

_HSYMBOLS = ...
_HSYMBOLS_VALUES = ...
def human2bytes(s):
    ...

_PROCS = ...
def get_info(process=..., interval=..., with_childs=...):
    """Return information about a process. (can be an pid or a Process object)

    If process is None, will return the information about the current process.
    """
    ...

TRUTHY_STRINGS = ...
FALSY_STRINGS = ...
def to_bool(s):
    ...

def to_signum(signum):
    """Resolves the signal number from arbitrary signal representation.

     Supported formats:
        10 - plain integers
        '10' - integers as a strings
        'KILL' - signal names
        'SIGKILL' - signal names with SIG prefix
        'SIGRTMIN+1' - signal names with offsets
    """
    ...

def to_str(s, encoding=..., errors=...):
    """cast bytes or string to string.
    errors options are strict, ignore or replace"""
    ...

def to_bytes(s, encoding=...):
    """cast str or bytes to bytes"""
    ...

if pwd is None:
    def to_uid(name):
        ...
    
else:
    def to_uid(name):
        """Return an uid, given a user name.
        If the name is an integer, make sure it's an existing uid.

        If the user name is unknown, raises a ValueError.
        """
        ...
    
if grp is None:
    def to_gid(name):
        ...
    
else:
    def to_gid(name):
        """Return a gid, given a group name

        If the group name is unknown, raises a ValueError.
        """
        ...
    
def get_username_from_uid(uid):
    """Return the username of a given uid."""
    ...

def get_default_gid(uid):
    """Return the default group of a specific user."""
    ...

def parse_env_str(env_str):
    ...

def parse_env_dict(env):
    ...

def replace_env(var):
    ...

def env_to_str(env):
    ...

if fcntl is None:
    def close_on_exec(fd):
        ...
    
else:
    def close_on_exec(fd):
        ...
    
def get_python_version():
    """Get a 3 element tuple with the python version"""
    ...

INDENTATION_LEVEL = ...
def debuglog(func):
    ...

def convert_opt(key, val):
    """ get opt
    """
    ...

class ImportStringError(ImportError):
    """Provides information about a failed :func:`import_string` attempt."""
    import_name = ...
    exception = ...
    def __init__(self, import_name, exception) -> None:
        ...
    
    def __repr__(self):
        ...
    


def resolve_name(import_name, silent=..., reload=...):
    """Imports an object based on a string.  This is useful if you want to
    use import paths as endpoints or something similar.  An import path can
    be specified either in dotted notation (``xml.sax.saxutils.escape``)
    or with a colon as object delimiter (``xml.sax.saxutils:escape``).

    If `silent` is True the return value will be `None` if the import fails.

    :param import_name: the dotted name for the object to import.
    :param silent: if set to `True` import errors are ignored and
                   `None` is returned instead.
    :param reload: if set to `True` modules that are already loaded will be
                   reloaded
    :return: imported object
    """
    ...

_SECTION_NAME = ...
_PATTERN1 = ...
_PATTERN2 = ...
_CIRCUS_VAR = ...
def replace_gnu_args(data, prefix=..., **options):
    ...

class ObjectDict(dict):
    def __getattr__(self, item):
        ...
    


def configure_logger(logger, level=..., output=..., loggerconfig=..., name=...):
    ...

class StrictConfigParser(RawConfigParser):
    ...


def get_connection(socket, endpoint, ssh_server=..., ssh_keyfile=...):
    ...

def load_virtualenv(watcher, py_ver=...):
    ...

def create_udp_socket(mcast_addr, mcast_port):
    """Create an udp multicast socket for circusd cluster auto-discovery.
    mcast_addr must be between 224.0.0.0 and 239.255.255.255
    """
    ...

class DictDiffer:
    """
    Calculate the difference between two dictionaries as:
    (1) items added
    (2) items removed
    (3) keys same in both but changed values
    (4) keys same in both and unchanged values
    """
    def __init__(self, current_dict, past_dict) -> None:
        ...
    
    def added(self):
        ...
    
    def removed(self):
        ...
    
    def changed(self):
        ...
    
    def unchanged(self):
        ...
    


def dict_differ(dict1, dict2):
    ...

def synchronized(name):
    ...

def tornado_sleep(duration):
    """Sleep without blocking the tornado event loop

    To use with a gen.coroutines decorated function
    Thanks to http://stackoverflow.com/a/11135204/433050
    """
    ...

class TransformableFuture(concurrent.Future):
    _upstream_future = ...
    _upstream_callback = ...
    _result = ...
    _exception = ...
    def set_transform_function(self, fn):
        ...
    
    def set_upstream_future(self, upstream_future):
        ...
    
    def result(self, timeout=...):
        ...
    
    def add_done_callback(self, fn):
        ...
    
    def exception(self, timeout=...):
        ...
    


def check_future_exception_and_log(future):
    ...

