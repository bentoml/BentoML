from textwrap import dedent
from typing import TYPE_CHECKING, Literal
import numpy as np
from pandas import DataFrame, Index, Series
from pandas._typing import AnyArrayLike, ArrayLike, DtypeObj, FrameOrSeriesUnion, final
from pandas.util._decorators import doc

if TYPE_CHECKING: ...
_shared_docs: dict[str, str] = ...
_hashtables = ...

def get_data_algo(values: ArrayLike): ...
def unique(values): ...

unique1d = ...

def isin(comps: AnyArrayLike, values: AnyArrayLike) -> np.ndarray: ...
def factorize_array(
    values: np.ndarray,
    na_sentinel: int = ...,
    size_hint: int | None = ...,
    na_value=...,
    mask: np.ndarray | None = ...,
) -> tuple[np.ndarray, np.ndarray]: ...
@doc(
    values=dedent(
        """    values : sequence
        A 1-D sequence. Sequences that aren't pandas objects are
        coerced to ndarrays before factorization.
    """
    ),
    sort=dedent(
        """    sort : bool, default False
        Sort `uniques` and shuffle `codes` to maintain the
        relationship.
    """
    ),
    size_hint=dedent(
        """    size_hint : int, optional
        Hint to the hashtable sizer.
    """
    ),
)
def factorize(
    values, sort: bool = ..., na_sentinel: int | None = ..., size_hint: int | None = ...
) -> tuple[np.ndarray, np.ndarray | Index]: ...
def value_counts(
    values,
    sort: bool = ...,
    ascending: bool = ...,
    normalize: bool = ...,
    bins=...,
    dropna: bool = ...,
) -> Series: ...
def value_counts_arraylike(values, dropna: bool): ...
def duplicated(
    values: ArrayLike, keep: Literal["first", "last", False] = ...
) -> np.ndarray: ...
def mode(values, dropna: bool = ...) -> Series: ...
def rank(
    values: ArrayLike,
    axis: int = ...,
    method: str = ...,
    na_option: str = ...,
    ascending: bool = ...,
    pct: bool = ...,
) -> np.ndarray: ...
def checked_add_with_arr(
    arr: np.ndarray,
    b,
    arr_mask: np.ndarray | None = ...,
    b_mask: np.ndarray | None = ...,
) -> np.ndarray: ...
def quantile(x, q, interpolation_method=...): ...

class SelectN:
    def __init__(self, obj, n: int, keep: str) -> None: ...
    def compute(self, method: str) -> FrameOrSeriesUnion: ...
    @final
    def nlargest(self): ...
    @final
    def nsmallest(self): ...
    @final
    @staticmethod
    def is_valid_dtype_n_method(dtype: DtypeObj) -> bool: ...

class SelectNSeries(SelectN):
    def compute(self, method: str) -> Series: ...

class SelectNFrame(SelectN):
    def __init__(self, obj, n: int, keep: str, columns) -> None: ...
    def compute(self, method: str) -> DataFrame: ...

def take(
    arr, indices: np.ndarray, axis: int = ..., allow_fill: bool = ..., fill_value=...
): ...
def searchsorted(arr, value, side=..., sorter=...) -> np.ndarray: ...

_diff_special = ...

def diff(arr, n: int, axis: int = ..., stacklevel: int = ...): ...
def safe_sort(
    values,
    codes=...,
    na_sentinel: int = ...,
    assume_unique: bool = ...,
    verify: bool = ...,
) -> np.ndarray | tuple[np.ndarray, np.ndarray]: ...
def union_with_duplicates(lvals: ArrayLike, rvals: ArrayLike) -> ArrayLike: ...
