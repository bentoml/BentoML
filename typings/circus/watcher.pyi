"""
This type stub file was generated by pyright.
"""

from tornado import gen
from circus import util

class Watcher:
    """
    Class managing a list of processes for a given command.

    Options:

    - **name**: name given to the watcher. Used to uniquely identify it.

    - **cmd**: the command to run. May contain *$WID*, which will be
      replaced by **wid**.

    - **args**: the arguments for the command to run. Can be a list or
      a string. If **args** is  a string, it's splitted using
      :func:`shlex.split`. Defaults to None.

    - **numprocesses**: Number of processes to run.

    - **working_dir**: the working directory to run the command in. If
      not provided, will default to the current working directory.

    - **shell**: if *True*, will run the command in the shell
      environment. *False* by default. **warning: this is a
      security hazard**.

    - **uid**: if given, is the user id or name the command should run
      with. The current uid is the default.

    - **gid**: if given, is the group id or name the command should run
      with. The current gid is the default.

    - **send_hup**: if True, a process reload will be done by sending
      the SIGHUP signal. Defaults to False.

    - **stop_signal**: the signal to send when stopping the process.
      Defaults to SIGTERM.

    - **stop_children**: send the **stop_signal** to the children too.
      Defaults to False.

    - **env**: a mapping containing the environment variables the command
      will run with. Optional.

    - **rlimits**: a mapping containing rlimit names and values that will
      be set before the command runs.

    - **stdout_stream**: a mapping that defines the stream for
      the process stdout. Defaults to None.

      Optional. When provided, *stdout_stream* is a mapping containing up to
      three keys:

      - **class**: the stream class. Defaults to
        `circus.stream.FileStream`
      - **filename**: the filename, if using a FileStream
      - **max_bytes**: maximum file size, after which a new output file is
        opened. defaults to 0 which means no maximum size (only applicable
        with FileStream).
      - **backup_count**: how many backups to retain when rotating files
        according to the max_bytes parameter. defaults to 0 which means
        no backups are made (only applicable with FileStream)

      This mapping will be used to create a stream callable of the specified
      class.
      Each entry received by the callable is a mapping containing:

      - **pid** - the process pid
      - **name** - the stream name (*stderr* or *stdout*)
      - **data** - the data

      This is not supported on Windows.

    - **stderr_stream**: a mapping that defines the stream for
      the process stderr. Defaults to None.

      Optional. When provided, *stderr_stream* is a mapping containing up to
      three keys:
      - **class**: the stream class. Defaults to `circus.stream.FileStream`
      - **filename**: the filename, if using a FileStream
      - **max_bytes**: maximum file size, after which a new output file is
        opened. defaults to 0 which means no maximum size (only applicable
        with FileStream)
      - **backup_count**: how many backups to retain when rotating files
        according to the max_bytes parameter. defaults to 0 which means
        no backups are made (only applicable with FileStream).

      This mapping will be used to create a stream callable of the specified
      class.

      Each entry received by the callable is a mapping containing:

      - **pid** - the process pid
      - **name** - the stream name (*stderr* or *stdout*)
      - **data** - the data

      This is not supported on Windows.

    - **priority** -- integer that defines a priority for the watcher. When
      the Arbiter do some operations on all watchers, it will sort them
      with this field, from the bigger number to the smallest.
      (default: 0)

    - **singleton** -- If True, this watcher has a single process.
      (default:False)

    - **use_sockets** -- If True, the processes will inherit the file
      descriptors, thus can reuse the sockets opened by circusd.
      (default: False)

    - **on_demand** -- If True, the processes will be started only
      at the first connection to the socket
      (default: False)

    - **copy_env** -- If True, the environment in which circus is running
      run will be reproduced for the workers. This defaults to True on
      Windows as you cannot run any executable without the **SYSTEMROOT**
      variable. (default: False)

    - **copy_path** -- If True, circusd *sys.path* is sent to the
      process through *PYTHONPATH*. You must activate **copy_env** for
      **copy_path** to work. (default: False)

    - **max_age**: If set after around max_age seconds, the process is
      replaced with a new one.  (default: 0, Disabled)

    - **max_age_variance**: The maximum number of seconds that can be added to
      max_age. This extra value is to avoid restarting all processes at the
      same time.  A process will live between max_age and
      max_age + max_age_variance seconds.

    - **hooks**: callback functions for hooking into the watcher startup
      and shutdown process. **hooks** is a dict where each key is the hook
      name and each value is a 2-tuple with the name of the callable
      or the callable itself and a boolean flag indicating if an
      exception occuring in the hook should not be ignored.
      Possible values for the hook name: *before_start*, *after_start*,
      *before_spawn*, *after_spawn*, *before_stop*, *after_stop*.,
      *before_signal*, *after_signal* or *extended_stats*.

    - **options** -- extra options for the worker. All options
      found in the configuration file for instance, are passed
      in this mapping -- this can be used by plugins for watcher-specific
      options.

    - **respawn** -- If set to False, the processes handled by a watcher will
      not be respawned automatically. (default: True)

    - **virtualenv** -- The root directory of a virtualenv. If provided, the
      watcher will load the environment for its execution. (default: None)

    - **stdin_socket**: If not None, the socket with matching name is placed
      at file descriptor 0 (stdin) of the processes.
      default: None.

    - **close_child_stdin**: If True, closes the stdin after the fork.
      default: True.

    - **close_child_stdout**: If True, closes the stdout after the fork.
      default: False.

    - **close_child_stderr**: If True, closes the stderr after the fork.
      default: False.

    - **use_papa**: If True, use the papa process kernel for this process.
      default: False.
    """
    def __init__(self, name, cmd, args=..., numprocesses=..., warmup_delay=..., working_dir=..., shell=..., shell_args=..., uid=..., max_retry=..., gid=..., send_hup=..., stop_signal=..., stop_children=..., env=..., graceful_timeout=..., prereload_fn=..., rlimits=..., executable=..., stdout_stream=..., stderr_stream=..., priority=..., loop=..., singleton=..., use_sockets=..., copy_env=..., copy_path=..., max_age=..., max_age_variance=..., hooks=..., respawn=..., autostart=..., on_demand=..., virtualenv=..., stdin_socket=..., close_child_stdin=..., close_child_stdout=..., close_child_stderr=..., virtualenv_py_ver=..., use_papa=..., **options) -> None:
        ...
    
    @property
    def pending_socket_event(self): # -> bool:
        ...
    
    @classmethod
    def load_from_config(cls, config): # -> Self@Watcher:
        ...
    
    @util.debuglog
    def initialize(self, evpub_socket, sockets, arbiter): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def notify_event(self, topic, msg): # -> None:
        """Publish a message on the event publisher channel"""
        ...
    
    @util.debuglog
    def reap_process(self, pid, status=...):
        """ensure that the process is killed (and not a zombie)"""
        ...
    
    @util.debuglog
    def reap_processes(self): # -> None:
        """Reap all the processes for this watcher.
        """
        ...
    
    @gen.coroutine
    @util.debuglog
    def manage_processes(self): # -> Generator[Future | list[Future], None, None]:
        """Manage processes."""
        ...
    
    @gen.coroutine
    @util.debuglog
    def remove_expired_processes(self): # -> Generator[list[Future], None, None]:
        ...
    
    @gen.coroutine
    @util.debuglog
    def reap_and_manage_processes(self): # -> Generator[Future, None, None]:
        """Reap & manage processes."""
        ...
    
    @gen.coroutine
    @util.debuglog
    def spawn_processes(self): # -> Generator[Future, None, None]:
        """Spawn processes.
        """
        ...
    
    def spawn_process(self, recovery_wid=...):
        """Spawn process.

        Return True if ok, False if the watcher must be stopped
        """
        ...
    
    @util.debuglog
    def send_signal_process(self, process, signum, recursive=...):
        """Send the signum signal to the process

        The signal is sent to the process itself then to all the children
        """
        ...
    
    @gen.coroutine
    @util.debuglog
    def kill_process(self, process, stop_signal=..., graceful_timeout=...):
        """Kill process (stop_signal, graceful_timeout then SIGKILL)
        """
        ...
    
    @gen.coroutine
    @util.debuglog
    def kill_processes(self, stop_signal=..., graceful_timeout=...): # -> Generator[Future, None, None]:
        """Kill all processes (stop_signal, graceful_timeout then SIGKILL)
        """
        ...
    
    @util.debuglog
    def send_signal(self, pid, signum): # -> None:
        ...
    
    @util.debuglog
    def send_signal_child(self, pid, child_id, signum): # -> None:
        """Send signal to a child.
        """
        ...
    
    @util.debuglog
    def send_signal_children(self, pid, signum, recursive=...): # -> None:
        """Send signal to all children.
        """
        ...
    
    @util.debuglog
    def status(self): # -> str:
        ...
    
    @util.debuglog
    def process_info(self, pid, extended=...):
        ...
    
    @util.debuglog
    def info(self, extended=...): # -> dict[Unknown, Unknown]:
        ...
    
    @util.synchronized("watcher_stop")
    @gen.coroutine
    def stop(self): # -> Generator[Future, None, None]:
        ...
    
    def get_active_processes(self): # -> list[Unknown]:
        """return a list of pids of active processes (not already stopped)"""
        ...
    
    def get_active_pids(self): # -> list[Unknown]:
        """return a list of pids of active processes (not already stopped)"""
        ...
    
    @property
    def pids(self): # -> list[Unknown]:
        """Returns a list of PIDs"""
        ...
    
    def call_hook(self, hook_name, **kwargs): # -> bool:
        """Call a hook function"""
        ...
    
    @util.synchronized("watcher_start")
    @gen.coroutine
    def start(self): # -> Generator[Future, None, None]:
        ...
    
    @util.synchronized("watcher_restart")
    @gen.coroutine
    def restart(self): # -> Generator[Future, None, None]:
        ...
    
    @util.synchronized("watcher_reload")
    @gen.coroutine
    def reload(self, graceful=..., sequential=...): # -> Generator[Future, None, None]:
        ...
    
    @gen.coroutine
    def set_numprocesses(self, np): # -> Generator[Future, None, None]:
        ...
    
    @util.synchronized("watcher_incr")
    @gen.coroutine
    @util.debuglog
    def incr(self, nb=...): # -> Generator[Future, None, None]:
        ...
    
    @util.synchronized("watcher_decr")
    @gen.coroutine
    @util.debuglog
    def decr(self, nb=...): # -> Generator[Future, None, None]:
        ...
    
    @util.synchronized("watcher_set_opt")
    def set_opt(self, key, val):
        """Set a watcher option.

        This function set the watcher options. unknown keys are ignored.
        This function return an action number:

        - 0: trigger the process management
        - 1: trigger a graceful reload of the processes;
        """
        ...
    
    @util.synchronized("watcher_do_action")
    @gen.coroutine
    def do_action(self, num): # -> Generator[Future, None, None]:
        ...
    
    @util.debuglog
    def options(self, *args): # -> list[Unknown]:
        ...
    
    def is_stopping(self): # -> bool:
        ...
    
    def is_stopped(self): # -> bool:
        ...
    
    def is_active(self): # -> bool:
        ...
    


