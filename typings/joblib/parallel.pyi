from typing import Any, Callable, Iterable, Literal, NewType, Optional, Union
from ._multiprocessing_helpers import mp
from ._parallel_backends import ParallelBackendBase
from .logger import Logger

BACKENDS = ...
DEFAULT_BACKEND = ...
DEFAULT_N_JOBS = ...
DEFAULT_THREAD_BACKEND = ...
_backend = ...
VALID_BACKEND_HINTS = ...
VALID_BACKEND_CONSTRAINTS = ...
EXTERNAL_BACKENDS = ...

def get_active_backend(prefer=..., require=..., verbose=...): ...

class parallel_backend:
    def __init__(
        self, backend, n_jobs=..., inner_max_num_threads=..., **backend_params
    ) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback): ...
    def unregister(self): ...

DEFAULT_MP_CONTEXT = ...
if hasattr(mp, "get_context"):
    method = ...

class BatchedCalls:
    def __init__(
        self, iterator_slice, backend_and_jobs, reducer_callback=..., pickle_cache=...
    ) -> None: ...
    def __call__(self): ...
    def __reduce__(self): ...
    def __len__(self): ...

def cpu_count(only_physical_cores=...): ...
def delayed(function: Callable[..., Any]) -> Callable[..., Any]: ...

class BatchCompletionCallBack:
    def __init__(self, dispatch_timestamp, batch_size, parallel) -> None: ...
    def __call__(self, out): ...

def register_parallel_backend(name, factory, make_default=...): ...
def effective_n_jobs(n_jobs=...): ...

Expr = NewType("Expr", str)

class Parallel(Logger):
    def __init__(
        self,
        n_jobs: Optional[int] = ...,
        backend: Union[str, ParallelBackendBase] = ...,
        verbose: Optional[int] = ...,
        timeout: Optional[float] = ...,
        pre_dispatch: Union[Literal["all"], int, Expr] = ...,
        batch_size: Union[int, Literal["auto"]] = ...,
        temp_folder: Optional[str] = ...,
        max_nbytes: Optional[Union[str, int]] = ...,
        mmap_mode: Optional[Literal["r+", "r", "w+", "c"]] = ...,
        prefer: Optional[Literal["processes", "threads"]] = ...,
        require: Optional[Literal["sharedmem"]] = ...,
    ) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, traceback): ...
    def dispatch_next(self): ...
    def dispatch_one_batch(self, iterator): ...
    def print_progress(self) -> None: ...
    def retrieve(self) -> None: ...
    def __call__(self, iterable: Iterable[Any]) -> Any: ...
    def __repr__(self) -> str: ...
