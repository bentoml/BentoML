"""
This type stub file was generated by pyright.
"""
from typing import Any, Callable, Dict, Generic, List
from typing import Literal as LiteralTyping
from typing import Optional as OptionalTyping
from typing import Protocol, Tuple, TypeVar, Union, overload

__version__: str = ...
__all__ = ["Schema", "And", "Or", "Regex", "Optional", "Use", "Forbidden", "Const", "Literal", "SchemaError", "SchemaWrongKeyError", "SchemaMissingKeyError", "SchemaForbiddenKeyError", "SchemaUnexpectedTypeError", "SchemaOnlyOneAllowedError"]
class SchemaError(Exception):
    """Error during Schema validation."""
    @overload
    def __init__(self, autos: List[str], errors: List[Exception]=...) -> None:
        ...
    @overload
    def __init__(self, autos: List[str], errors: None=...) -> None:
        ...

    @property
    def code(self) -> str:
        """
        Removes duplicates values in auto and error list.
        parameters.
        """
        ...

GenericType = Union["Schema", "And", "Or", "Use", "Optional", "Regex", "Literal", "Const"]
DictType = Dict[Union[str, GenericType], Any]

_VT = TypeVar("_VT")
_VT_co = TypeVar("_VT_co", covariant=True)


class LambdaProtocol(Protocol[_VT_co, _VT_co]):
    def __call__(*args: Any, **kwargs: Any) -> Any: ...


class SchemaWrongKeyError(SchemaError):
    """Error Should be raised when an unexpected key is detected within the
    data set being."""
    ...


class SchemaMissingKeyError(SchemaError):
    """Error should be raised when a mandatory key is not found within the
    data set being validated"""
    ...


class SchemaOnlyOneAllowedError(SchemaError):
    """Error should be raised when an only_one Or key has multiple matching candidates"""
    ...


class SchemaForbiddenKeyError(SchemaError):
    """Error should be raised when a forbidden key is found within the
    data set being validated, and its value matches the value that was specified"""
    ...


class SchemaUnexpectedTypeError(SchemaError):
    """Error should be raised when a type mismatch is detected within the
    data set being validated."""
    ...


class And:
    """
    Utility function to combine validation directives in AND Boolean fashion.
    """
    @overload
    def __init__(self, *args: Any, error: str=...,schema: OptionalTyping[DictType]=...,ignore_extra_keys: bool=...) -> None:
        ...
    @overload
    def __init__(self, *args: LambdaProtocol[Any], error: List[str]=...,schema: OptionalTyping[DictType]=...,ignore_extra_keys: bool=...) -> None:
        ...
    @overload
    def __init__(self, *args: Any, error: List[str]=...,schema: OptionalTyping[DictType]=...,ignore_extra_keys: bool=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def args(self) -> Tuple[Any, ...]:
        """The provided parameters"""
        ...

    def validate(self, data: DictType) -> DictType:
        """
        Validate data using defined sub schema/expressions ensuring all
        values are valid.
        :param data: to be validated with sub defined schemas.
        :return: returns validated data
        """
        ...



class Or(And):
    """Utility function to combine validation directives in a OR Boolean
    fashion."""
    @overload
    def __init__(self, *args: Any, error: str=...,schema: OptionalTyping[DictType]=...,ignore_extra_keys: bool=... , only_one: bool=...,) -> None:
        ...
    @overload
    def __init__(self, *args: Any, error: List[str]=...,schema: OptionalTyping[DictType]=...,ignore_extra_keys: bool=... , only_one: bool=...,) -> None:
        ...

    def reset(self) -> None:
        ...

    def validate(self, data: DictType) -> DictType:
        """
        Validate data using sub defined schema/expressions ensuring at least
        one value is valid.
        :param data: data to be validated by provided schema.
        :return: return validated data if not validation
        """
        ...



class Regex:
    """
    Enables schema.py to validate string using regular expressions.
    """
    NAMES: List[str]= ...
    def __init__(self, pattern_str: str, flags: OptionalTyping[int]=..., error: OptionalTyping[str]=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def pattern_str(self) -> str:
        """The pattern for the represented regular expression"""
        ...

    def validate(self, data: str) -> str:
        """
        Validated data using defined regex.
        :param data: data to be validated
        :return: return validated data.
        """
        ...



class Use:
    """
    For more general use cases, you can use the Use class to transform
    the data while it is being validate.
    """
    def __init__(self, callable_: Callable[..., Any], error: OptionalTyping[str]=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    def validate(self, data: DictType) -> DictType:
        ...


COMPARABLE=LiteralTyping["0"]
CALLABLE=LiteralTyping["1"]
VALIDATOR=LiteralTyping["2"]
TYPE=LiteralTyping["3"]
DICT = LiteralTyping["4"]
ITERABLE=LiteralTyping["5"]

def _priority(s: type) -> Union[CALLABLE, COMPARABLE, VALIDATOR, TYPE, DICT, ITERABLE]: ...

class Schema:
    """
    Entry point of the library, use this class to instantiate validation
    schema for the data that will be validated.
    """
    def __init__(self, schema: DictType, error: OptionalTyping[str]=..., ignore_extra_keys: OptionalTyping[bool]=..., name: OptionalTyping[str]=..., description: OptionalTyping[str]=..., as_reference: OptionalTyping[bool]=...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def schema(self) -> DictType:
        ...

    @property
    def description(self) -> str:
        ...

    @property
    def name(self) -> str:
        ...

    @property
    def ignore_extra_keys(self) -> bool:
        ...

    @staticmethod
    def _dict_key_priority(s: type) -> Union[float, int]: ...

    @staticmethod
    def _is_optional_type(s: type) -> bool:...

    def is_valid(self, data: Any) -> bool:
        """Return whether the given data has passed all the validations
        that were specified in the given schema.
        """
        ...

    def _prepend_schema_name(self, message: str) -> str:...

    @overload
    def validate(self, data: DictType) -> DictType:
        ...
    @overload
    def validate(self, data: Any) -> DictType:
        ...

    def json_schema(self, schema_id: Any, use_refs: OptionalTyping[bool]=...) -> Dict[str, Any]:
        """Generate a draft-07 JSON schema dict representing the Schema.
        This method must be called with a schema_id.

        :param schema_id: The value of the $id on the main schema
        :param use_refs: Enable reusing object references in the resulting JSON schema.
                         Schemas with references are harder to read by humans, but are a lot smaller when there
                         is a lot of reuse
        """
        ...



class Optional(Schema):
    """Marker for an optional part of the validation Schema."""
    _MARKER: object = ...
    default: object
    key: str
    def __init__(self, schema: str, error: OptionalTyping[str]=..., ignore_extra_keys: OptionalTyping[bool]=..., name: OptionalTyping[str]=..., description: OptionalTyping[str]=..., as_reference: OptionalTyping[bool]=..., default: OptionalTyping[Any]=...) -> None:
        ...

    def __hash__(self) -> int:
        ...

    def __eq__(self, other: Optional) -> bool:
        ...

    def reset(self) -> None:
        ...


_HookCallback = Callable[[str, DictType, str], SchemaError]

class Hook(Schema):
    key: DictType
    def __init__(self, schema: DictType, error: OptionalTyping[str]=..., ignore_extra_keys: OptionalTyping[bool]=..., name: OptionalTyping[str]=..., description: OptionalTyping[str]=..., as_reference: OptionalTyping[bool]=..., handler: OptionalTyping[_HookCallback]=...) -> None:
        ...



class Forbidden(Hook):
    handler: Callable[[str, DictType, str], SchemaForbiddenKeyError]
    def __init__(self, schema: DictType, error: OptionalTyping[str]=..., ignore_extra_keys: OptionalTyping[bool]=..., name: OptionalTyping[str]=..., description: OptionalTyping[str]=..., as_reference: OptionalTyping[bool]=...) -> None:
        ...


class Literal(object):
    def __init__(self, value: str, description: OptionalTyping[str]=...) -> None:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    @property
    def description(self) -> str:
        ...

    @property
    def schema(self) -> str:
        ...



class Const(Schema):
    def validate(self, data: DictType) -> DictType:
        ...

def _callable_str(callable_: Callable[..., Any]) -> str: ...

def _plural_s(sized: str) -> str: ...

